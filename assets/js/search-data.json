{
  
    
        "post0": {
            "title": "Chapter 3: Dictionaries and Sets",
            "content": "Dictionaries are not just another dataset in python, they are an itergral part of the language. Hence Dicts are highly optimized, Dicts are implemented using hash tables. Sets are also build using hash tables and hence covered with this. . Generic Mapping Types - Mapping and MutableMapping . Both of these form the base classes for dicts and sets. The collection.abs module provides these. For implementing specialized mappings we often extend dict or collection.UserDict instead of ABCs. The main value of ABCs is documenting and formalizing the minimal interfaces for mapping. . from collections.abc import Mapping my_dict = {} isinstance(my_dict, Mapping) . True . The dict has one requirement and that is that the keys should be hashable. What do you mean by hashable? . An object is hashable if it has a hash value which never changes during its lifetime (it needs a __hash__() method), and can be compared to other objects (it needs an __eq__() method). Hashable objects which compare equal must have the same hash value. . print(hash((1, 2, 3)), hash(&#39;1, 2, 3&#39;), hash(1)) print(hash([1, 2, 3])) . 529344067295497451 4576582733818374657 1 . TypeErrorTraceback (most recent call last) &lt;ipython-input-8-146e8d157a5b&gt; in &lt;module&gt; 1 print(hash((1, 2, 3)), hash(&#39;1, 2, 3&#39;), hash(1)) -&gt; 2 print(hash([1, 2, 3])) TypeError: unhashable type: &#39;list&#39; . a = dict(one=1, two=2, three=3) b = {&#39;one&#39;: 1, &#39;two&#39;: 2, &#39;three&#39;: 3} c = dict(zip([&#39;one&#39;, &#39;two&#39;, &#39;three&#39;], [1, 2, 3])) d = dict([(&#39;two&#39;, 2), (&#39;one&#39;, 1), (&#39;three&#39;, 3)]) e = dict({&#39;three&#39;: 3, &#39;two&#39;: 2, &#39;one&#39;:1}) a == b == c == d == e . True . dict Comprehensions . the syntax of listcomps and genexps can be used . nums = {num: str(num) for num in range(10)} nums . {0: &#39;0&#39;, 1: &#39;1&#39;, 2: &#39;2&#39;, 3: &#39;3&#39;, 4: &#39;4&#39;, 5: &#39;5&#39;, 6: &#39;6&#39;, 7: &#39;7&#39;, 8: &#39;8&#39;, 9: &#39;9&#39;} . Overview of Common Mapping Methods . There are 3 main dictionary types. dict, defaultdict, orderedDict. . Handlying Missing Keys with setdefault . dicts have a get function which is what is used most of the time when you want to handle missing keys (every pythonista knows this one!). In some cases where we have to handle key error and use a default value when the keys is not present don&#39;t use get to define the default value, instead use setdefault function. Use the 2 wisely. Most of the time setdefault() is a wise choice because using get() can lead to more searches. This is when you are inserting. if you also what to do a lookup... . Mappings with Flexible Key Lookup . There are 2 other methods to do this. . Use defaultdict - this expect a callable to be passed to the defaultdict constructor that will be called when there is a key error in the __getitem__. Note this will only be called for __getitem__ and not for other functions like .get(). Under the hood, it is using the __missing__ special methods. | subclass dict and add a __missing__ method - when __getitem__ is called with a key that is not present, it calls the __missing__ function if it is implemented to handle it. | from collections import defaultdict # takes a callable which is called when there is a key error d = defaultdict(list) d[0] # what happend? -&gt; calls list() to create list and inserts that into key . [] . but under the hood defaultdict uses the __missing__ method. This method is used to handle the missing values in any mapping object. . class PinToFun(dict): # the __getitem in dict calls this function def __missing__(self, key): if isinstance(key, str): # check to avoid recursion raise KeyError(key) return self[str(key)] def get(self, key, default=None): try: return self[key] except KeyError: return default def __contains__(self, key): return key in self.keys() or str(key) in self.keys() . pins = {&#39;0&#39;: &#39;I/O&#39;, &#39;1&#39;: &#39;LED&#39;} pins[&#39;0&#39;] . &#39;I/O&#39; . pins[0] . KeyErrorTraceback (most recent call last) &lt;ipython-input-12-bc9cb425f661&gt; in &lt;module&gt; -&gt; 1 pins[0] KeyError: 0 . pins_improved = PinToFun({&#39;0&#39;: &#39;I/O&#39;}) pins_improved[0] . &#39;I/O&#39; . pins_improved.get(0) . &#39;I/O&#39; . Variations of Dict: . collections.OrderedDict: Maintains keys in insertion order. Hence iteration is predictable. . collections.ChainMap: class is provided for quickly linking a number of mappings so they can be treated as a single unit. It is often much faster than creating a new dictionary and running multiple update()calls . collections.Counter: Holds the integer count of each key. Can be used to count instances of hashable objects. has addition functions like most_common to return the odered list of tuples. . from collections import Counter ct = Counter(&#39;abaaachdddrllkk&#39;) ct . Counter({&#39;a&#39;: 4, &#39;b&#39;: 1, &#39;c&#39;: 1, &#39;h&#39;: 1, &#39;d&#39;: 3, &#39;r&#39;: 1, &#39;l&#39;: 2, &#39;k&#39;: 2}) . collections.UserDict: Used as base class for creating new mapping classes. The main reason we don&#39;t use dict as base class is that it has some implementation shortcuts that we will have to override in order to make it work. Note that UserDict does not inherit from dict instead has data, which is a dict instance to avoid possible recursion issues. . we will now modify the PinToFun class using this to show its effectiveness. . import collections class PinToFun(collections.UserDict): def __missing__(self, key): if isinstance(key, str): raise KeyError(key) return self[str(key)] def __contains__(self, key): return str(key) in self.data def __setitem__(self, key, item): #here the data is accessed as an attribute self.data[str(key)] = item . pins = PinToFun({&#39;0&#39;: &#39;I/O&#39;, &#39;1&#39;: &#39;LED&#39;}) pins . {&#39;0&#39;: &#39;I/O&#39;, &#39;1&#39;: &#39;LED&#39;} . 0 in pins . True . Immutable Mappings . mapping types are mutable but if you want to constrain the user from making changes, use this. . Introducing MappingProxyType from types module. This returns a read-only by dynamic view of the original mapping. Hence updates can be seen but no changes can be performed using the mappingproxy . from types import MappingProxyType d = {1: &#39;A&#39;} d_proxy = MappingProxyType(d) d_proxy . mappingproxy({1: &#39;A&#39;}) . d_proxy[1] . &#39;A&#39; . d_proxy[0] = &#39;B&#39; . TypeErrorTraceback (most recent call last) &lt;ipython-input-3-c636e28161a2&gt; in &lt;module&gt; -&gt; 1 d_proxy[0] = &#39;B&#39; TypeError: &#39;mappingproxy&#39; object does not support item assignment . d[0] = &#39;B&#39; d_proxy[0] . &#39;B&#39; . Set Theory . An underused concept in python. The basic use is removing duplicate elements. Set elements must be hashable. . In addition to that sets also support basic set operations. . a | b - Union | a &amp; b - Intersection | a - b - Difference | . Sets have extremely fast membership functions. If used effectively it can make you code faster and easier to read. . l = [&#39;spam&#39;, &#39;eggs&#39;, &#39;spam&#39;, &#39;spam&#39;, &#39;spam&#39;] l . [&#39;spam&#39;, &#39;eggs&#39;, &#39;spam&#39;, &#39;spam&#39;, &#39;spam&#39;] . set(l) . {&#39;eggs&#39;, &#39;spam&#39;} . s = {1} type(s) . set . s . {1} . s.pop() . 1 . s # set() is used to denote empty set there is no literal notation for sets . set() . %time # this is faster and cleaner s = {1, 2, 3, 1} s . CPU times: user 1e+03 ns, sys: 0 ns, total: 1e+03 ns Wall time: 2.62 µs . {1, 2, 3} . %time s = set([1, 2, 3, 1]) s . CPU times: user 1 µs, sys: 4 µs, total: 5 µs Wall time: 8.58 µs . {1, 2, 3} . Using the literal set syntax is faster and more readable than calling the constructor set([1, 2, 3]). The latter is slower because when you use the literal, python directly calls the BUILD_SET bytecode to create the set. . from dis import dis #disassembe bytecode dis(&#39;{1}&#39;) . 1 0 LOAD_CONST 0 (1) 2 BUILD_SET 1 4 RETURN_VALUE . dis(&#39;set([1])&#39;) . 1 0 LOAD_NAME 0 (set) 2 LOAD_CONST 0 (1) 4 BUILD_LIST 1 6 CALL_FUNCTION 1 8 RETURN_VALUE . frozenset(range(10)) . frozenset({0, 1, 2, 3, 4, 5, 6, 7, 8, 9}) . The advantage of frozenset is that they are hashable while sets are not. So a frozenset can be used inside a set but nested sets are not possible. . f = frozenset(range(10)) s = set(range(10)) f, s . (frozenset({0, 1, 2, 3, 4, 5, 6, 7, 8, 9}), {0, 1, 2, 3, 4, 5, 6, 7, 8, 9}) . new_set = {f} new_set = {s} . TypeErrorTraceback (most recent call last) &lt;ipython-input-33-0e201e86858f&gt; in &lt;module&gt; 1 new_set = {f} -&gt; 2 new_set = {s} TypeError: unhashable type: &#39;set&#39; . {i for i in &#39;abcdeeefghhijkkkll&#39;} . {&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;, &#39;f&#39;, &#39;g&#39;, &#39;h&#39;, &#39;i&#39;, &#39;j&#39;, &#39;k&#39;, &#39;l&#39;} . dict and set under the Hood . dict and set has really fast membership operations (lookup) due to the fact that they are implemented using hash tables. Comparing this with something like a list, there is a world of difference. All this is due to the hash tables. . Hash Tables . It is implemented as a sparse array. Each cell in the array is called a bucket. In a dict table each bucket has 2 fields, a ref to the key and a ref to the value item. . Python tries to keep 1/3 of the buckets empty. If its size increases it is copied out to a know location with larger memory. The first set in putting an element inside is to hash the item. . To put an item in hash table, the first step is to calculate the hash value of the item key. This is a unique value for the given data type. The hash() function is called, which in turn uses the __hash__ for calculating the hash. . hash(1) . 1 . If 2 objs compare equal there hash values must be equal. . hash(1), hash(1.0) . (1, 1) . Also hashes for objects that are similar to should be as different as possible. . hash(1.001), hash(1.002) . (2305843009213441, 4611686018427393) . Note: There is a detailed overview of the hash table algorithms in the book. Please google for it to find it. (It is in page 89 in the book). I actually forgot all about hashes, shouldn&#39;t have skipped those classes in college... . Practical Consequeces of How dict Works . keys must be hashable objects - the object must support hash() funtion and eq() function. also if a == b the hash(a) == hash(b). By default all user objects are hashable. . | dicts have significant memory overhead - since dicts use sparese arrays they are not efficient. Note that if your using dicts in JSON style with one dict per object, a namedtuple is far more efficent alternative. . | Key search is fast (very fast) - hash tables are the reason. . | Key ordering depends on insertion order - Consider the case where a key collition happens. . | Adding items to dict may change the order of existing keys - this is why modifing the contents of a dict while iterating through it is a bad idea. If you need to scan and add items to a dict, do it in 2 steps. . | Practical Concequeces of how sets Work . similar to dict, sets and frozensets also implement hash tables but each bucket only holds a reference. Just like dicts but without a value to go with it. similar concequences as above. . Dictionaries are a keystone of Python. Beyond the basic dict , the standard library offers handy, ready-to-use specialized mappings like defaultdict , OrderedDict , ChainMap , and Counter , all defined in the collections module. The same module also provides the easy-to-extend UserDict class. . Two powerful methods available in most mappings are setdefault and update . The setdefault method is used to update items holding mutable values, for example, in a dict of list values, to avoid redundant searches for the same key. The update method allows bulk insertion or overwriting of items from any other mapping, from iterables providing (key, value) pairs and from keyword arguments. Mapping constructors also use update internally, allowing instances to be initialized from mappings, iterables, or keyword arguments. . A clever hook in the mapping API is the missing method, which lets you customize what happens when a key is not found. The collections.abc module provides the Mapping and MutableMapping abstract base classes for reference and type checking. The little-known MappingProxyType from the types module creates immutable mappings. There are also ABCs for Set and Mutable Set . . he hash table implementation underlying dict and set is extremely fast. Understand‐ ing its logic explains why items are apparently unordered and may even be reordered behind our backs. There is a price to pay for all this speed, and the price is in memory. .",
            "url": "https://jjmachan.github.io/fluent-python/2021/07/25/ch3-dictionaries-and-sets.html",
            "relUrl": "/2021/07/25/ch3-dictionaries-and-sets.html",
            "date": " • Jul 25, 2021"
        }
        
    
  
    
        ,"post1": {
            "title": "Chapter 2: An Array of Sequences",
            "content": "Overview of build-in Sequence . Container Sequence They hold references of other objects. They can store different types of objects. Eg list, tuple, collections.deque. . | Flat Sequence Physically store the objects in its own memory space. Store similar values. Eg str, byte, memoryview, array.array . | they can also be catogrised as immutable and mutable. . List Comprehensions and Generator Expressions . Listcomps are more readable since they are only used to build new lists. They are also really powerfull. They are also specific, listcomps can only do one thing, build new lists. . [i for i in range(10)] . [0, 1, 2, 3, 4, 5, 6, 7, 8, 9] . Listcomps can also do everything the map and filter functions perform, without using python lambda. Its seems to be faster in simple use cases too. . colors = [&#39;black&#39;, &#39;white&#39;] sizes = [&#39;S&#39;, &#39;M&#39;, &#39;L&#39;, &#39;XL&#39;] # do not the order of the for loops determins the order of the product tshirts = [(color, size) for color in colors for size in sizes] tshirts . [(&#39;black&#39;, &#39;S&#39;), (&#39;black&#39;, &#39;M&#39;), (&#39;black&#39;, &#39;L&#39;), (&#39;black&#39;, &#39;XL&#39;), (&#39;white&#39;, &#39;S&#39;), (&#39;white&#39;, &#39;M&#39;), (&#39;white&#39;, &#39;L&#39;), (&#39;white&#39;, &#39;XL&#39;)] . Generator Expressions . Listcomps build lists, but to fill up all other sequences, genexp is the way to go. You can build tuples, arrays and other sequences from listcomps but genexps saves memory because they only generate one element at a time instead of storing the whole thing in memory with a list and just passing it into another constructor . symbols = &#39;$¢£¥€¤&#39; tuple(ord(symbol) for symbol in symbols) . (36, 162, 163, 165, 8364, 164) . genexp = (i for i in range(10)) listcomp = [i for i in range(10)] genexp, listcomp . (&lt;generator object &lt;genexpr&gt; at 0x7f382dfc30b0&gt;, [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]) . %%timeit # seems like genexps are faster too! for i in listcomp: #print(i) pass . 224 ns ± 1.3 ns per loop (mean ± std. dev. of 7 runs, 1000000 loops each) . %%timeit for i in genexp: #print(i) pass . 41.5 ns ± 0.399 ns per loop (mean ± std. dev. of 7 runs, 10000000 loops each) . import array array.array(&#39;I&#39;, (ord(symbol) for symbol in symbols)) . array(&#39;I&#39;, [36L, 194L, 162L, 194L, 163L, 194L, 165L, 226L, 130L, 172L, 194L, 164L]) . The main advantage of genexp is that they are never build in memory. So in cases where you just want to use the resulting sequence and not save it this becomes handy. This make genexps really scalable. For example if you took the cartician product we did with listcomps earlier and wanted to do that for a million colors and sizes just so that you can print them out will lead to huge use of memory, but if you use a genexp, only one item needs to be created when executing each loop. . Tuples are not just Immutable Lists . Tuples are immutable lists and records with no field names . Tuples as Records . tuples hold record, each item in the tuple holds data for one field and the position of the item gives its meaning. They work as good record because we can easily upack them in order. using * to grab excess items . traveler_ids = [(&#39;USA&#39;, &#39;31195855&#39;), (&#39;BRA&#39;, &#39;CE342567&#39;), (&#39;ESP&#39;, &#39;XDA205856&#39;)] for country, passport in sorted(traveler_ids): print(&#39;%s/%s&#39; % (country, passport)) . BRA/CE342567 ESP/XDA205856 USA/31195855 . one, two, *rest = range(1, 10) print(one, two) print(rest) . 1 2 [3, 4, 5, 6, 7, 8, 9] . Tuple unpacking does work with any interable object, you only have to ensure that when unpacking you map each individual item to 1 corresponding variable (except when the variable has a * operator like in the above example . nested tuples are also handled just like you would expect . metro_areas = [ (&#39;Tokyo&#39;, &#39;JP&#39;, 36.933, (35.689722, 139.691667)), # (&#39;Delhi NCR&#39;, &#39;IN&#39;, 21.935, (28.613889, 77.208889)), (&#39;Mexico City&#39;, &#39;MX&#39;, 20.142, (19.433333, -99.133333)), (&#39;New York-Newark&#39;, &#39;US&#39;, 20.104, (40.808611, -74.020386)), (&#39;Sao Paulo&#39;, &#39;BR&#39;, 19.649, (-23.547778, -46.635833)), ] print(&#39;{:15} | {:^9} | {:^9}&#39;.format(&#39;&#39;, &#39;lat.&#39; , &#39;long.&#39;)) fmt = &#39;{:15} | {:9.4f} | {:9.4f}&#39; for name, cc, population, (lat, long) in metro_areas: if long &lt;= 0: print(fmt.format(name, lat, long)) . | lat. | long. Mexico City | 19.4333 | -99.1333 New York-Newark | 40.8086 | -74.0204 Sao Paulo | -23.5478 | -46.6358 . Named Tuples . Names tuples function is a factory that produces a subclass of tuples that attaches field names and class names to it. They also use the same amt of memory as a tuple but less that an object would because it doesn&#39;t have a __dict__. This makes it ideal for used where you want an object to contain all the data that is associated with it but doesn&#39;t have function of its own . namedtuple( &lt;class name&gt; , &lt; field names: Optional(iter, str)&gt; ) . from collections import namedtuple City = namedtuple(&#39;City&#39;, &#39;city state country&#39;) Kochi = City(&#39;Kochi&#39;, &#39;Kerala&#39;, &#39;India&#39;) Kochi . City(city=&#39;Kochi&#39;, state=&#39;Kerala&#39;, country=&#39;India&#39;) . from collections import namedtuple # takes the name of the class and either a iterable with field names or as a string in which field # names are seperated by space City = namedtuple(&#39;City&#39;, &#39;name county population coordinates&#39;) tokyo = City(&#39;Tokyo&#39;, &#39;JP&#39;, 36.933, (35.689722, 139.691667)) tokyo . City(name=&#39;Tokyo&#39;, county=&#39;JP&#39;, population=36.933, coordinates=(35.689722, 139.691667)) . tokyo.population . 36.933 . NamedTuple has a few attributes in addition to the ones in tuple. the most useful ones are _fields, _make(iterable), _asdict() . print(City._fields) # gets the field names print(tokyo._asdict()) LatLong = namedtuple(&#39;LatLong&#39;, &#39;lat long&#39;) delhi_data = (&#39;Delhi NCR&#39;, &#39;IN&#39;, 21.935, LatLong(28.613889, 77.208889)) print(City._make(delhi_data)) # allows you to init a named tuple from a # iterable; City(*delhi_data) would do the same . (&#39;name&#39;, &#39;county&#39;, &#39;population&#39;, &#39;coordinates&#39;) {&#39;name&#39;: &#39;Tokyo&#39;, &#39;county&#39;: &#39;JP&#39;, &#39;population&#39;: 36.933, &#39;coordinates&#39;: (35.689722, 139.691667)} City(name=&#39;Delhi NCR&#39;, county=&#39;IN&#39;, population=21.935, coordinates=LatLong(lat=28.613889, long=77.208889)) . Slicing . This is pretty straight forward but none the less very powerful. Lets see all their advanced usecases here. . Why Slices and Range exclude the last item? . This is because that way its more intutive for zero-based indexing used in python and c. . Slice Objects . How slice is works . strs = &#39;bicycle&#39; strs[::-1], strs[::3], strs[::-2] . (&#39;elcycib&#39;, &#39;bye&#39;, &#39;eccb&#39;) . Internally [a:b:c] creates a slice object slice(a, b, c) which is invoked by the obj.__getitem__(slice(start, stop, step)). This is handy since you can now get slice working your own objects. . You can also assign to slices. . reverse = slice(None, None, -1) strs[reverse] . &#39;elcycib&#39; . Multidimensional Slicing and Ellipsis . the [] operator can also take multiple indexes or slices seperated by commas. This is used, for instance, in the external NumPy package, where items of a two-dimensional numpy.ndarray can be fetched using the syntax a[i, j] or 2-d slice as a[m:n, k:l] . The ellipsis (3 full stops ...) is valid token by the python parser. In Numpy it is used as a shortcut when slicing arrays of many dimensions for example if x is a 4-d array x[i, ...] is a shortcut for x[i, :, :, :,] . Assigning to Slices . Mutable sequnces can be grafted or modified in place using the slice notation. You can also del slices. . l = list(range(10)) l . [0, 1, 2, 3, 4, 5, 6, 7, 8, 9] . l[2:5] = [20, 30] l . [0, 1, 20, 30, 5, 6, 7, 8, 9] . del l[5:7] l . [0, 1, 20, 30, 5, 8, 9] . l[2:5] = 100 . TypeErrorTraceback (most recent call last) &lt;ipython-input-10-da8b10461280&gt; in &lt;module&gt; -&gt; 1 l[2:5] = 100 TypeError: can only assign an iterable . l[2:5] = [100] l . [0, 1, 100, 8, 9] . Using + and * with Seqences . concatenation is a common operation with any sequence but there are some subtle details as to how they work. When using the */+ both sequences have to be of the same time and none of them is modified, instead a new on is created . &#39;abc&#39; * 3 . &#39;abcabcabc&#39; . &#39;abc&#39; + &#39;def&#39; . &#39;abcdef&#39; . Building Lists of Lists . now this can bite you when you don&#39;t expect it to. Sometimes you want to init a new list with certain number of nested lists, the best way to do this is with list comprehension. . board = [[&#39;_&#39;] * 3 for i in range(3)] board . [[&#39;_&#39;, &#39;_&#39;, &#39;_&#39;], [&#39;_&#39;, &#39;_&#39;, &#39;_&#39;], [&#39;_&#39;, &#39;_&#39;, &#39;_&#39;]] . board[2][2] = &#39;X&#39; board . [[&#39;_&#39;, &#39;_&#39;, &#39;_&#39;], [&#39;_&#39;, &#39;_&#39;, &#39;_&#39;], [&#39;_&#39;, &#39;_&#39;, &#39;X&#39;]] . weird_board = [[&#39;_&#39;]*3 ]*3 weird_board[2][2] = &#39;2&#39; weird_board . [[&#39;_&#39;, &#39;_&#39;, &#39;2&#39;], [&#39;_&#39;, &#39;_&#39;, &#39;2&#39;], [&#39;_&#39;, &#39;_&#39;, &#39;2&#39;]] . Here the outer list is made up of refferences of the inner list. Here the issue is that the above code acts similar to this . row = [&#39;_&#39;] * 3 board = [] for i in range(3): board.append(row) . The same row gets appended 3 times. On the other hand using list comprehension is similar to this code . board = [] for i in range(3): row = [&#39;_&#39;] * 3 board.append(row) . Augmented Assignment with Sequences . Using operators like *= += behaves very differently depending on the first operand. The special method that works is __iadd__(inplace addition). If it is not implemented, pythons falls back to __add__. If __iadd__ is present and the sequence is mutable then the operation happens in place. If either of the conditions is false then pythons calls __add__ and assigns the result to the object. . l = [1, 2, 3] print(l, id(l)) l *= 2 print(l, id(l)) t = (1, 2, 3) print(t, id(t)) t *= 2 print(t, id(t)) . [1, 2, 3] 140649174697408 [1, 2, 3, 1, 2, 3] 140649174697408 (1, 2, 3) 140649174633216 (1, 2, 3, 1, 2, 3) 140649217792800 . Sort and Sorted . list.sort() sorts the list in place and returns a None object to signal this. Infact this is a common practice in Python standard lib to return None from functions that operate on objects in place. . The build-in function sorted() on the other hand creates a new array and returns it. . Both of them take 2 arguments . reverse - which is a flag which tells to sort in reverse order | key - A one argument function that generates a key for each element to sort | fruits = [&#39;grape&#39;, &#39;raspberry&#39;, &#39;apple&#39;, &#39;banana&#39;] sorted(fruits) . [&#39;apple&#39;, &#39;banana&#39;, &#39;grape&#39;, &#39;raspberry&#39;] . fruits . [&#39;grape&#39;, &#39;raspberry&#39;, &#39;apple&#39;, &#39;banana&#39;] . fruits.sort() . fruits . [&#39;apple&#39;, &#39;banana&#39;, &#39;grape&#39;, &#39;raspberry&#39;] . Managing Ordered Sequences with bisect . bisect finds the insert point for an item in a list and returns the index, then we use list.insert(index, item) to add the item to the corresponding index. the bisect module also has an efficient implementation of binary search which can be used. . bisect offers 2 functions - bisect and insort . import bisect import sys HAYSTACK = [1, 4, 5, 6, 8, 12, 15, 20, 21, 23, 23, 26, 29, 30] NEEDLES = [0, 1, 2, 5, 8, 10, 22, 23, 29, 30, 31] ROW_FMT = &#39;{0:2d} @ {1:2d} {2}{0:&lt;2d}&#39; def demo(bisect_fn): for needle in reversed(NEEDLES): position = bisect_fn(HAYSTACK, needle) offset = position * &#39; |&#39; print(ROW_FMT.format(needle, position, offset)) def main(add_to=&#39;right&#39;): if add_to == &#39;left&#39;: bisect_fn = bisect.bisect_left else: bisect_fn = bisect.bisect print(&#39;DEMO: &#39;, bisect_fn.__name__) print(&#39;haystack -&gt;&#39;, &#39; &#39;.join(&#39;%2d&#39;%n for n in HAYSTACK)) demo(bisect_fn) . main() . DEMO: bisect_right haystack -&gt; 1 4 5 6 8 12 15 20 21 23 23 26 29 30 31 @ 14 | | | | | | | | | | | | | |31 30 @ 14 | | | | | | | | | | | | | |30 29 @ 13 | | | | | | | | | | | | |29 23 @ 11 | | | | | | | | | | |23 22 @ 9 | | | | | | | | |22 10 @ 5 | | | | |10 8 @ 5 | | | | |8 5 @ 3 | | |5 2 @ 1 |2 1 @ 1 |1 0 @ 0 0 . main(add_to=&#39;left&#39;) . DEMO: bisect_left haystack -&gt; 1 4 5 6 8 12 15 20 21 23 23 26 29 30 31 @ 14 | | | | | | | | | | | | | |31 30 @ 13 | | | | | | | | | | | | |30 29 @ 12 | | | | | | | | | | | |29 23 @ 9 | | | | | | | | |23 22 @ 9 | | | | | | | | |22 10 @ 5 | | | | |10 8 @ 4 | | | |8 5 @ 2 | |5 2 @ 1 |2 1 @ 0 1 0 @ 0 0 . bisect has is really bisect_right, which inserts the same element always to the right of the corresponing element in the list. It also has a sister function bisect_left which corresponds to inserting the same item to left of the matching item in the list . bisect has another function called bisect.insort(seq, item) which inserts an the item into seq, this is much faster than using insert() . %%time haystack = HAYSTACK[:] idx = bisect.bisect(haystack, 19) haystack.insert(idx, 19) print(haystack) . [1, 4, 5, 6, 8, 12, 15, 19, 20, 21, 23, 23, 26, 29, 30] CPU times: user 2.41 ms, sys: 0 ns, total: 2.41 ms Wall time: 1.51 ms . %%time haystack = HAYSTACK[:] bisect.insort(haystack, 19) print(haystack) . [1, 4, 5, 6, 8, 12, 15, 19, 20, 21, 23, 23, 26, 29, 30] CPU times: user 161 µs, sys: 30 µs, total: 191 µs Wall time: 198 µs . import bisect import random SIZE = 7 my_list = [] for i in range(SIZE): new_item = random.randrange(SIZE*2) bisect.insort(my_list, new_item) print(&#39;%2d -&gt;&#39;%new_item, my_list) . 5 -&gt; [5] 8 -&gt; [5, 8] 3 -&gt; [3, 5, 8] 6 -&gt; [3, 5, 6, 8] 13 -&gt; [3, 5, 6, 8, 13] 0 -&gt; [0, 3, 5, 6, 8, 13] 9 -&gt; [0, 3, 5, 6, 8, 9, 13] . When a List is Not all the Answer . when we are starting out we tend to overuse lists for everything. But there are times when other sequence objects make more sense. Let explore some of them. . if you need large list of floating points it&#39;s better to user arrays since the only store the numerical value and not float object, just like how C/C++ implements. . | if you need FIFO, LIFO operation consider the deque . | if you do frequent membership checks, a set is much more efficient (note they are not a sequence since they are not ordered). . | . Arrays . Array can be used to store same type of numeraical data and are as efficient as C-arrays. You can also provide a typecode (a letter) to determine the underlying C type used. . from array import array from random import random # create a array to hold decimal float floats = array(&#39;d&#39;, (random() for i in range(10**7))) . floats[-1] . 0.19034769013593422 . fp = open(&#39;floats.bin&#39;, &#39;wb&#39;) floats.tofile(fp) # size = 77M fp.close() . float2 = array(&#39;d&#39;) fp = open(&#39;floats.bin&#39;, &#39;rb&#39;) float2.fromfile(fp, 10**7) fp.close() float2[-1] . 0.19034769013593422 . float2 == floats . True . Here we are creating a new int array using the old HAYSTACK . HAYSTACK . [1, 4, 5, 6, 8, 12, 15, 20, 21, 23, 23, 26, 29, 30] . a = array(&#39;i&#39;, reversed(HAYSTACK)) a . array(&#39;i&#39;, [30, 29, 26, 23, 23, 21, 20, 15, 12, 8, 6, 5, 4, 1]) . Array doesn&#39;t have a built-in sort mechanism, you can create a new sorted array easily though. . a = array(a.typecode, sorted(a)) a . array(&#39;i&#39;, [1, 4, 5, 6, 8, 12, 15, 20, 21, 23, 23, 26, 29, 30]) . bisect.bisect(a, 8), bisect.insort(a, 8), a . (5, None, array(&#39;i&#39;, [1, 4, 5, 6, 8, 8, 12, 15, 20, 21, 23, 23, 26, 29, 30])) . Memory Views . A memoryview is essentially a generalized NumPy array structure in Python itself (without the math). It allows you to share memory between data-structures (things like PIL images, SQLlite databases, NumPy arrays, etc.) without first copying. This is very important for large data sets Travis Oliphant, lead author of Num-py memoryview has a case method that returns yet another memoryview object which is sharing the same memory. . import array . numbers = array.array(&#39;h&#39;, [-2, -1, 0, 1, 2]) memv = memoryview(numbers) len(memv) # apparently there is some issue with python3 hence not used # ref - https://stackoverflow.com/questions/4877866/why-is-it-not-possible-to-get-a-py-buffer-from-an-array-object . 5 . print(memv[0]) memv_oct = memv.cast(&#39;B&#39;) memv_oct.tolist(), memv_oct[5], numbers . -2 . ([254, 255, 255, 255, 0, 0, 1, 0, 2, 0], 0, array(&#39;h&#39;, [-2, -1, 0, 1, 2])) . Numpy ans SciPy . Now if your doing advanced array and matrix operation numpy and scipy are your gotos. These libs are the reason by python is so popular in the scientific communities. The key point of these libraries was that they were fast and reliable because it leverages the widely used C and Fortran code base. . Deque and other Queues . lists are great but constrained for appending or poping from the left, deque on the other hand is optimized for operating from both sides (but is poor for operations in the middle). We use the Queue data structure for a wide range of algos and hence we have an optimised implementation of that in python. . collections.deque is a thread-safe double-ended queue designed for fast insertion and deletion from both ends. They can also be bounded to a fixed length so if you add any new elements after that, the data will be discarded from the top (first entered data point first). . from collections import deque dq = deque(range(10), maxlen=10) dq . deque([0, 1, 2, 3, 4, 5, 6, 7, 8, 9]) . dq.rotate(3) dq . deque([7, 8, 9, 0, 1, 2, 3, 4, 5, 6]) . dq.append(2) dq . deque([8, 9, 0, 1, 2, 3, 4, 5, 6, 2]) . dq.appendleft(-1) dq . deque([-1, 8, 9, 0, 1, 2, 3, 4, 5, 6]) . dq.extend([11, 12, 13]) dq . deque([0, 1, 2, 3, 4, 5, 6, 11, 12, 13]) . dq.maxlen . 10 . dq.extendleft([10, 20, 30, 40]) dq . deque([40, 30, 20, 10, 0, 1, 2, 3, 4, 5]) . the append() and popleft operations are atomic, so deque is safe to use as a LIFO queue in multithreaded applications without the need for locks. . Other implementations of Queues . queue: This provides the synchronized (i.e., thread-safe) classes Queue , LifoQueue , and PriorityQueue . These are used for safe communication between threads. All three classes can be bounded by providing a maxsize argument greater than 0 to the constructor. However, they don’t discard items to make room as deque does. In‐stead, when the queue is full the insertion of a new item blocks—i.e., it waits until some other thread makes room by taking an item from the queue, which is useful to throttle the number of live threads. . multiprocessing Implements its own bounded Queue , very similar to queue.Queue but designed for interprocess communication. A specialized multiprocessing.JoinableQueue is also available for easier task management. . asyncio Newly added to Python 3.4, asyncio provides Queue , LifoQueue , PriorityQueue, and JoinableQueue with APIs inspired by the classes contained in the queue and multiprocessing modules, but adapted for managing tasks in asynchronous pro‐gramming. . heapq In contrast to the previous three modules, heapq does not implement a queue class, but provides functions like heappush and heappop that let you use a mutable sequence as a heap queue or priority queue. .",
            "url": "https://jjmachan.github.io/fluent-python/2021/07/19/ch2-array-of-sequences.html",
            "relUrl": "/2021/07/19/ch2-array-of-sequences.html",
            "date": " • Jul 19, 2021"
        }
        
    
  
    
        ,"post2": {
            "title": "Chapter 1: Data Model",
            "content": "Pythonic Card Deck . To undertant how python works as a framework it is crutial that you get the Python Data Model. Python is very consistent and by that I mean that once you have some experince with the language you can start to correctly make informed guesses on other features about python even if its new. This will help you make your objects more pythonic by leveraging the options python has for: . Iteration | Collections | Attribute access | Operator overloading | Function and method invocation | Object creation and destruction | String representation and formatting | Managed contexts (i.e., with blocks) | Studing these will give you the power to make your own python object play nicely with the python language and use many of the freatures mentioned above. In short makes you code &quot;pythonic&quot;. . Let see an example to show you the power of __getitem__ and __len__. . import collections # namedtuple - tuples with names for each value in it (much like a class) Card = collections.namedtuple(&#39;Card&#39;, [&#39;rank&#39;, &#39;suit&#39;]) c = Card(&#39;7&#39;, &#39;diamonds&#39;) # individual card object print(c) print(c.rank, c.suit) . Card(rank=&#39;7&#39;, suit=&#39;diamonds&#39;) 7 diamonds . class FrenchDeck: ranks = [str(n) for n in range(2, 11)] + list(&#39;JQKA&#39;) suits = &#39;spades diamonds clubs hearts&#39;.split() def __init__(self): self._cards = [Card(rank, suit) for suit in self.suits for rank in self.ranks] def __len__(self): return len(self._cards) def __getitem__(self, position): return self._cards[position] . deck = FrenchDeck() # with this simple class, we can already use `len` and `__getitem__` len(deck), deck[0] . (52, Card(rank=&#39;2&#39;, suit=&#39;spades&#39;)) . Now we have created a class FrenchDeck that is short but still packs a punch. All the basic operations are supported. Now imagine we have another usecase to pick a random card. Normally we would add another function but in this case we can use pythons existing lib function random.choice(). . from random import choice choice(deck) . Card(rank=&#39;5&#39;, suit=&#39;hearts&#39;) . We’ve just seen two advantages of using special methods to leverage the Python data model:&gt; 1. The users of your classes don’t have to memorize arbitrary method names for stan‐dard operations (“How to get the number of items? Is it .size() , .length() , or what?”). . It’s easier to benefit from the rich Python standard library and avoid reinventing the wheel, like the random.choice function. | But we have even more features . deck[1:5] . [Card(rank=&#39;3&#39;, suit=&#39;spades&#39;), Card(rank=&#39;4&#39;, suit=&#39;spades&#39;), Card(rank=&#39;5&#39;, suit=&#39;spades&#39;), Card(rank=&#39;6&#39;, suit=&#39;spades&#39;)] . for card in deck: if card.rank == &#39;K&#39;: print(card) . Card(rank=&#39;K&#39;, suit=&#39;spades&#39;) Card(rank=&#39;K&#39;, suit=&#39;diamonds&#39;) Card(rank=&#39;K&#39;, suit=&#39;clubs&#39;) Card(rank=&#39;K&#39;, suit=&#39;hearts&#39;) . # the in operator does a sequential scan. Card(&#39;Q&#39;, &#39;spades&#39;) in deck . True . Card(&#39;M&#39;, &#39;spades&#39;) in deck . False . we can also make use the build-in sorted() function. We just need to proved a function for providing the values of the cards. Here the logic is provided in spedes_high . suit_value = dict(spades=3, hearts=2, diamonds=1, clubs=0) def spades_high(card): rank_value = FrenchDeck.ranks.index(card.rank) return rank_value*len(suit_value) + suit_value[card.suit] . for card in sorted(deck, key=spades_high)[:10]: print(card) . Card(rank=&#39;2&#39;, suit=&#39;clubs&#39;) Card(rank=&#39;2&#39;, suit=&#39;diamonds&#39;) Card(rank=&#39;2&#39;, suit=&#39;hearts&#39;) Card(rank=&#39;2&#39;, suit=&#39;spades&#39;) Card(rank=&#39;3&#39;, suit=&#39;clubs&#39;) Card(rank=&#39;3&#39;, suit=&#39;diamonds&#39;) Card(rank=&#39;3&#39;, suit=&#39;hearts&#39;) Card(rank=&#39;3&#39;, suit=&#39;spades&#39;) Card(rank=&#39;4&#39;, suit=&#39;clubs&#39;) Card(rank=&#39;4&#39;, suit=&#39;diamonds&#39;) . Although FrenchDeck implicitly inherits from object its functionality is not inherited, but comes from leveraging the data model and composition. By implementing the special methods __len__ and __getitem__ , our FrenchDeck behaves like a standard Python sequence, allowing it to benefit from core language features (e.g., iteration and slicing). and from the standard library, as shown by the examples using random.choice , reversed , and sorted . Thanks to composition, the __len__ and __getitem__ imple‐ mentations can hand off all the work to a list object, self._cards . . How special methods are used . Normally you just define these special methods and call them via the inbuild methods like len() in [index] instead of calling it via object.__len__(). This gives you speed up in some cases and also plays nicely with other other python library functions since they all are now interfacing with the same endpoints. . Enumerating Numeric Types . Special methods can also be used to repond to operators like +, - etc. We will see an example of vector operations. . from math import hypot . class Vector: def __init__(self, x=0, y=0): self.x = x self.y = y def __repr__(self): return &#39;Vector(%d, %d)&#39; %(self.x, self.y) def __abs__(self): return hypot(self.x, self.y) def __bool__(self): return bool(self.x or self.y) def __add__(self, other): x = self.x + other.x y = self.y + other.y return Vector(x, y) def __mul__(self, scalar): x = scalar * self.x y = scalar * self.y return Vector(x, y) . v = Vector(3, 4) a = Vector(0, 0) print(v) print(abs(v)) print(v*2) print(v + a) . Vector(3, 4) 5.0 Vector(6, 8) Vector(3, 4) . As you can see we implemented many special methods but we don&#39;t directly invoke them. The special methods are to be invoked by the interpretor most of the time, unless you are doing a lot of metaprogramming. . bool(a) . True . String Representation . We use the __repr__ special method to get the buildin string representation of of the object for inspection (note the usage in vector object. There are also other special methods like __repr__with__str__ which is called by str() or __str__ which is used to return a string for display to the end user. If your only implementing 1 function stick with __repr__ since print() will fall back to that if __str__ is not found. . Arithmetic Operators . In the above example we have implemented __add__ and __mul__. Note in both cases we are returning new object, reading from self, and other. This is the expected behaviour. . Boolean Value of Custom Type . In python any object can be used in a boolean context. If __bool__ or __len__ is not implemented then the object will be truthy by default. IF __bool__ is implemented that is called, if not python calls __len__ and checks if the length is 0. . class Test: def __init__(self, x): self.x = x t = Test(0) t, bool(t) . (&lt;__main__.Test at 0x7fed149a53a0&gt;, True) . class Test: def __init__(self, x): self.x = x def __bool__(self): return bool(self.x) t = Test(0) t, bool(t) . (&lt;__main__.Test at 0x7fed149acd30&gt;, False) . Why len is Not a Method . Practicality beats purity . len (similar to abs) in built-in data types, has a shortcut implmentation in CPython and they are just returning their length from the values defined in the c struct code. This makes it super fast for built-in data types. You can also consider these as unary operations. .",
            "url": "https://jjmachan.github.io/fluent-python/2021/07/02/ch1-data-model.html",
            "relUrl": "/2021/07/02/ch1-data-model.html",
            "date": " • Jul 2, 2021"
        }
        
    
  
    
        ,"post3": {
            "title": "Fastpages Notebook Blog Post",
            "content": "About . This notebook is a demonstration of some of capabilities of fastpages with notebooks. . With fastpages you can save your jupyter notebooks into the _notebooks folder at the root of your repository, and they will be automatically be converted to Jekyll compliant blog posts! . Front Matter . The first cell in your Jupyter Notebook or markdown blog post contains front matter. Front matter is metadata that can turn on/off options in your Notebook. It is formatted like this: . # &quot;My Title&quot; &gt; &quot;Awesome summary&quot; - toc:true- branch: master - badges: true - comments: true - author: Hamel Husain &amp; Jeremy Howard - categories: [fastpages, jupyter] . Setting toc: true will automatically generate a table of contents | Setting badges: true will automatically include GitHub and Google Colab links to your notebook. | Setting comments: true will enable commenting on your blog post, powered by utterances. | . The title and description need to be enclosed in double quotes only if they include special characters such as a colon. More details and options for front matter can be viewed on the front matter section of the README. . Markdown Shortcuts . A #hide comment at the top of any code cell will hide both the input and output of that cell in your blog post. . A #hide_input comment at the top of any code cell will only hide the input of that cell. . The comment #hide_input was used to hide the code that produced this. . put a #collapse-hide flag at the top of any cell if you want to hide that cell by default, but give the reader the option to show it: . import pandas as pd import altair as alt . . put a #collapse-show flag at the top of any cell if you want to show that cell by default, but give the reader the option to hide it: . cars = &#39;https://vega.github.io/vega-datasets/data/cars.json&#39; movies = &#39;https://vega.github.io/vega-datasets/data/movies.json&#39; sp500 = &#39;https://vega.github.io/vega-datasets/data/sp500.csv&#39; stocks = &#39;https://vega.github.io/vega-datasets/data/stocks.csv&#39; flights = &#39;https://vega.github.io/vega-datasets/data/flights-5k.json&#39; . . place a #collapse-output flag at the top of any cell if you want to put the output under a collapsable element that is closed by default, but give the reader the option to open it: . print(&#39;The comment #collapse-output was used to collapse the output of this cell by default but you can expand it.&#39;) . The comment #collapse-output was used to collapse the output of this cell by default but you can expand it. . . Interactive Charts With Altair . Charts made with Altair remain interactive. Example charts taken from this repo, specifically this notebook. . Example 1: DropDown . # use specific hard-wired values as the initial selected values selection = alt.selection_single( name=&#39;Select&#39;, fields=[&#39;Major_Genre&#39;, &#39;MPAA_Rating&#39;], init={&#39;Major_Genre&#39;: &#39;Drama&#39;, &#39;MPAA_Rating&#39;: &#39;R&#39;}, bind={&#39;Major_Genre&#39;: alt.binding_select(options=genres), &#39;MPAA_Rating&#39;: alt.binding_radio(options=mpaa)} ) # scatter plot, modify opacity based on selection alt.Chart(df).mark_circle().add_selection( selection ).encode( x=&#39;Rotten_Tomatoes_Rating:Q&#39;, y=&#39;IMDB_Rating:Q&#39;, tooltip=&#39;Title:N&#39;, opacity=alt.condition(selection, alt.value(0.75), alt.value(0.05)) ) . Example 2: Tooltips . alt.Chart(df).mark_circle().add_selection( alt.selection_interval(bind=&#39;scales&#39;, encodings=[&#39;x&#39;]) ).encode( alt.X(&#39;Rotten_Tomatoes_Rating&#39;, type=&#39;quantitative&#39;), alt.Y(&#39;IMDB_Rating&#39;, type=&#39;quantitative&#39;, axis=alt.Axis(minExtent=30)), # y=alt.Y(&#39;IMDB_Rating:Q&#39;, ), # use min extent to stabilize axis title placement tooltip=[&#39;Title:N&#39;, &#39;Release_Date:N&#39;, &#39;IMDB_Rating:Q&#39;, &#39;Rotten_Tomatoes_Rating:Q&#39;] ).properties( width=500, height=400 ) . Example 3: More Tooltips . label = alt.selection_single( encodings=[&#39;x&#39;], # limit selection to x-axis value on=&#39;mouseover&#39;, # select on mouseover events nearest=True, # select data point nearest the cursor empty=&#39;none&#39; # empty selection includes no data points ) # define our base line chart of stock prices base = alt.Chart().mark_line().encode( alt.X(&#39;date:T&#39;), alt.Y(&#39;price:Q&#39;, scale=alt.Scale(type=&#39;log&#39;)), alt.Color(&#39;symbol:N&#39;) ) alt.layer( base, # base line chart # add a rule mark to serve as a guide line alt.Chart().mark_rule(color=&#39;#aaa&#39;).encode( x=&#39;date:T&#39; ).transform_filter(label), # add circle marks for selected time points, hide unselected points base.mark_circle().encode( opacity=alt.condition(label, alt.value(1), alt.value(0)) ).add_selection(label), # add white stroked text to provide a legible background for labels base.mark_text(align=&#39;left&#39;, dx=5, dy=-5, stroke=&#39;white&#39;, strokeWidth=2).encode( text=&#39;price:Q&#39; ).transform_filter(label), # add text labels for stock prices base.mark_text(align=&#39;left&#39;, dx=5, dy=-5).encode( text=&#39;price:Q&#39; ).transform_filter(label), data=stocks ).properties( width=500, height=400 ) . Data Tables . You can display tables per the usual way in your blog: . df[[&#39;Title&#39;, &#39;Worldwide_Gross&#39;, &#39;Production_Budget&#39;, &#39;Distributor&#39;, &#39;MPAA_Rating&#39;, &#39;IMDB_Rating&#39;, &#39;Rotten_Tomatoes_Rating&#39;]].head() . Title Worldwide_Gross Production_Budget Distributor MPAA_Rating IMDB_Rating Rotten_Tomatoes_Rating . 0 The Land Girls | 146083.0 | 8000000.0 | Gramercy | R | 6.1 | NaN | . 1 First Love, Last Rites | 10876.0 | 300000.0 | Strand | R | 6.9 | NaN | . 2 I Married a Strange Person | 203134.0 | 250000.0 | Lionsgate | None | 6.8 | NaN | . 3 Let&#39;s Talk About Sex | 373615.0 | 300000.0 | Fine Line | None | NaN | 13.0 | . 4 Slam | 1087521.0 | 1000000.0 | Trimark | R | 3.4 | 62.0 | . Images . Local Images . You can reference local images and they will be copied and rendered on your blog automatically. You can include these with the following markdown syntax: . ![](my_icons/fastai_logo.png) . . Remote Images . Remote images can be included with the following markdown syntax: . ![](https://image.flaticon.com/icons/svg/36/36686.svg) . . Animated Gifs . Animated Gifs work, too! . ![](https://upload.wikimedia.org/wikipedia/commons/7/71/ChessPawnSpecialMoves.gif) . . Captions . You can include captions with markdown images like this: . ![](https://www.fast.ai/images/fastai_paper/show_batch.png &quot;Credit: https://www.fast.ai/2020/02/13/fastai-A-Layered-API-for-Deep-Learning/&quot;) . . Other Elements . GitHub Flavored Emojis . Typing I give this post two :+1:! will render this: . I give this post two :+1:! . Tweetcards . Typing &gt; twitter: https://twitter.com/jakevdp/status/1204765621767901185?s=20 will render this: Altair 4.0 is released! https://t.co/PCyrIOTcvvTry it with: pip install -U altairThe full list of changes is at https://t.co/roXmzcsT58 ...read on for some highlights. pic.twitter.com/vWJ0ZveKbZ . &mdash; Jake VanderPlas (@jakevdp) December 11, 2019 . Youtube Videos . Typing &gt; youtube: https://youtu.be/XfoYk_Z5AkI will render this: . Boxes / Callouts . Typing &gt; Warning: There will be no second warning! will render this: . Warning: There will be no second warning! . Typing &gt; Important: Pay attention! It&#39;s important. will render this: . Important: Pay attention! It&#8217;s important. . Typing &gt; Tip: This is my tip. will render this: . Tip: This is my tip. . Typing &gt; Note: Take note of this. will render this: . Note: Take note of this. . Typing &gt; Note: A doc link to [an example website: fast.ai](https://www.fast.ai/) should also work fine. will render in the docs: . Note: A doc link to an example website: fast.ai should also work fine. . Footnotes . You can have footnotes in notebooks, however the syntax is different compared to markdown documents. This guide provides more detail about this syntax, which looks like this: . For example, here is a footnote {% fn 1 %}. And another {% fn 2 %} {{ &#39;This is the footnote.&#39; | fndetail: 1 }} {{ &#39;This is the other footnote. You can even have a [link](www.github.com)!&#39; | fndetail: 2 }} . For example, here is a footnote 1. . And another 2 . 1. This is the footnote.↩ . 2. This is the other footnote. You can even have a link!↩ .",
            "url": "https://jjmachan.github.io/fluent-python/jupyter/2020/02/20/test.html",
            "relUrl": "/jupyter/2020/02/20/test.html",
            "date": " • Feb 20, 2020"
        }
        
    
  

  
  

  

  
  

  
  

  
  

  
  

  
  

  
      ,"page7": {
          "title": "",
          "content": "Sitemap: {{ “sitemap.xml” | absolute_url }} | .",
          "url": "https://jjmachan.github.io/fluent-python/robots.txt",
          "relUrl": "/robots.txt",
          "date": ""
      }
      
  

}