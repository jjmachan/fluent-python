{
  
    
        "post0": {
            "title": "Chapter 7: Function Decorators and Closures",
            "content": "Decorator 101 . The decorator is a callable that takes another function as argument. The decorator helps to transform the function as follows. . @decorator def target(): print(&#39;running target()&#39;) # has the same effect as def target(): print(&#39;running target&#39;) target = decorator(target) . The first crucial fact about decorators is that they have the power to replace the decorated function with a different one. . Second crucial fact is that they are exectuted immediately when a module is loaded. A key feature to note here is that the decorator runs right after the decorated function is defined, which is usually at import time . registry = [] def register(func): print(&#39;running register (%s)&#39;%func) registry.append(func) return func @register def f1(): print(&#39;running f1()&#39;) @register def f2(): print(&#39;running f2()&#39;) def f3(): print(&#39;running f3()&#39;) def main(): print(&#39;running main()&#39;) print(&#39;register -&gt; &#39;, registry) f1() f2() f3() . running register (&lt;function f1 at 0x7f1f2c435670&gt;) running register (&lt;function f2 at 0x7f1f2c35b1f0&gt;) . main() . running main() register -&gt; [&lt;function f1 at 0x7f1f2c435670&gt;, &lt;function f2 at 0x7f1f2c35b1f0&gt;] running f1() running f2() running f3() . This emphasis the point that function decorators are executed as soon as the module is imported but the imported functions run only when they are explicitly called. This is what Pythonistas call importtime and runtime . Decorator-Enhanced Strategy Pattern . Decorators offer a way of implementing the bestprom functionality from the prev chapter. Here we can use decorators to register each promo code and that way minmise code reuse. . promos = [] def promotion(promo_func): promos.append(promo_func) return promo_func @promotion def fidelity(order): &quot;&quot;&quot;5% discount for customers with 1000 or more fidelity points&quot;&quot;&quot; return order.total() * .05 if order.customer.fidelity &gt;= 1000 else 0 @promotion def bulk_item(order): &quot;&quot;&quot;10% discount for each LineItem with 20 or more units&quot;&quot;&quot; discount = 0 for item in order.cart: if item.quantity &gt;= 20: discount += item.total() * .1 return discount @promotion def large_order(order): &quot;&quot;&quot;7% discount for orders with 10 or more distinct items&quot;&quot;&quot; distinct_items = {item.product for item in order.cart} if len(distinct_items) &gt;= 10: return order.total() * .07 return 0 def best_promo(order): &quot;&quot;&quot;Select best discount available &quot;&quot;&quot; return max(promo(order) for promo in promos) . Now in the above examples we saw cases the decorators send back the same function, but most of the decorators do change the function. This is done by defining a inner function and returning that. To understand that better lets look at Closures and varialbe scope rules. . Variable Scope Rules . Below we have definied as function that reads 2 variable: a local var a and a var b that is not defined. . def f1(a): print(a) print(b) f1(4) . 4 . NameErrorTraceback (most recent call last) &lt;ipython-input-5-876a9d93f0d6&gt; in &lt;module&gt; 3 print(b) 4 -&gt; 5 f1(4) &lt;ipython-input-5-876a9d93f0d6&gt; in f1(a) 1 def f1(a): 2 print(a) -&gt; 3 print(b) 4 5 f1(4) NameError: name &#39;b&#39; is not defined . # but if we define a global variable b b = 10 f1(4) . 4 10 . def f2(a): print(a) print(b) b = 5 f2(10) . 10 . UnboundLocalErrorTraceback (most recent call last) &lt;ipython-input-7-44688ef5aa7c&gt; in &lt;module&gt; 4 b = 5 5 -&gt; 6 f2(10) &lt;ipython-input-7-44688ef5aa7c&gt; in f2(a) 1 def f2(a): 2 print(a) -&gt; 3 print(b) 4 b = 5 5 UnboundLocalError: local variable &#39;b&#39; referenced before assignment . Why this happens? . when Python compiles the body of the function, it decides that b is a local variable because it is assigned within the function. The generated bytecode reflects this decision and will try to fetch b from the local environment. Later, when the call f2(3) is made, the body of f2 fetches and prints the value of the local variable a , but when trying to fetch the value of local variable b it discovers that b is unbound. . def f3(a): # use the global b global b print(a) print(b) b = 9 f3(3) . 3 10 . b . 9 . from dis import dis dis(f1) . 2 0 LOAD_GLOBAL 0 (print) 2 LOAD_FAST 0 (a) 4 CALL_FUNCTION 1 6 POP_TOP 3 8 LOAD_GLOBAL 0 (print) 10 LOAD_GLOBAL 1 (b) 12 CALL_FUNCTION 1 14 POP_TOP 16 LOAD_CONST 0 (None) 18 RETURN_VALUE . dis(f2) . 2 0 LOAD_GLOBAL 0 (print) 2 LOAD_FAST 0 (a) 4 CALL_FUNCTION 1 6 POP_TOP 3 8 LOAD_GLOBAL 0 (print) 10 LOAD_FAST 1 (b) 12 CALL_FUNCTION 1 14 POP_TOP 4 16 LOAD_CONST 1 (5) 18 STORE_FAST 1 (b) 20 LOAD_CONST 0 (None) 22 RETURN_VALUE . Closues . closue is a function with an extended scope that encompasses nonglobal variables referenced in the body fo the function but not defined there. . Now to show this in practice lets build a function avg() that calculates the average of all the numbers that are called using the concept of closures. . def make_averager(): series = [] def averager(new_value): series.append(new_value) total = sum(series) return total/len(series) return averager . avg = make_averager() avg(10) . 10.0 . avg(11) . 10.5 . avg(12) . 11.0 . look at series variable. Its accessed in averager() function where its is no longer a local variable, but averager is still able to call series.append(). . In this case series is what we technically call a free variable. It is a variable that is not bound in the local scope. . Lets inspect the function created by make_averager . avg.__code__.co_varnames . (&#39;new_value&#39;, &#39;total&#39;) . avg.__code__.co_freevars . (&#39;series&#39;,) . The binding for series is kept in the __closure__ attribute of the return function avg. Each item in avg.__closure__ corresponds to a name in avg.__code__.co_freevars. These items are cells, and they have an attribute called cell_contents where the actual values can be found. . avg.__code__.co_freevars . (&#39;series&#39;,) . avg.__closure__ . (&lt;cell at 0x7f3a548da890: list object at 0x7f3a548bfe10&gt;,) . avg.__closure__[0].cell_contents . [10, 11, 12] . To summarize: a closure is a function that retains the bindings of the free variables that exist when the function is defined, so that they can be used later when the function is invoked and the defining scope is no longer available. . Note that the only situation in which a function may need to deal with external variables that are nonglobal is when it is nested in another function. . nonlocal Declaration . Our implementation of make_average is not opimal. A better way would be to problably store the total and the number of values. . Now lets look at a broken implementation of the same. . def make_average(): total = 0 count = 0 def average(new_value): total += new_value count += 1 return total/count return average avg = make_average() avg(10) . UnboundLocalError Traceback (most recent call last) &lt;ipython-input-2-27f4f3e80f71&gt; in &lt;module&gt; 11 12 avg = make_average() &gt; 13 avg(10) &lt;ipython-input-2-27f4f3e80f71&gt; in average(new_value) 4 5 def average(new_value): -&gt; 6 total += new_value 7 count += 1 8 return total/count UnboundLocalError: local variable &#39;total&#39; referenced before assignment . Surprise! it errors out. Here if you notice, inside the average() function the statement is count += 1 where count is a number or an immutable type (yeah int is an immutable type). But this statement makes count a local variable. The issue is there for total. . We didn&#39;t have this previously beacause it was a list and mutable, but for immutable objects which we can only read this is not possible. . To work arond this, the nonlocal declaration was introduced. nonlocal specifies that the variables are still free variables. . def make_averager(): total = 0 count = 0 def averager(new_value): nonlocal count, total count += 1 total += new_value return total/count return averager avg = make_averager() avg(10) . 10.0 . Implementing a Simple Decorator . import time def clock(func): def clocked(*args): t0 = time.perf_counter() result = func(*args) elapsed = time.perf_counter() - t0 name = func.__name__ arg_str = &#39;, &#39;.join(repr(arg) for arg in args) print(&#39;[%0.8fs] %s(%s) -&gt; %r&#39;%(elapsed, name, arg_str, result)) return result return clocked . import time @clock def snooze(seconds): time.sleep(seconds) @clock def factorial(n): &quot;&quot;&quot; Calculates the factorial of n recursively. &quot;&quot;&quot; return 1 if n &lt; 2 else n*factorial(n-1) if __name__==&#39;__main__&#39;: print(&#39;*&#39; * 40, &#39;Calling snooze(.123)&#39;) snooze(.123) print(&#39;*&#39; * 40, &#39;Calling factorial(6)&#39;) print(&#39;6! =&#39;, factorial(6)) . **************************************** Calling snooze(.123) [0.12316652s] snooze(0.123) -&gt; None **************************************** Calling factorial(6) [0.00000196s] factorial(1) -&gt; 1 [0.00004121s] factorial(2) -&gt; 2 [0.00026267s] factorial(3) -&gt; 6 [0.00091569s] factorial(4) -&gt; 24 [0.00099629s] factorial(5) -&gt; 120 [0.00102192s] factorial(6) -&gt; 720 6! = 720 . factorial.__name__, factorial.__doc__ . (&#39;clocked&#39;, None) . As you can see the factorial function is changed an points to the function returned by the doecorator. The function in the decorator is doing the work. This is evident from the __name__ attribute of the factorial function. It is changed to &quot;clocked&quot;. . Our decorator has a few issues, it doesnot handle keyword arguments and masks the __name__ and __doc__. We hence use functools.wraps decorator . import time import functools def clock(func): @functools.wraps(func) def clocked(*args, **kwargs): t0 = time.perf_counter() result = func(*args, **kwargs) elapsed = time.perf_counter() - t0 name = func.__name__ arg_str = &#39;, &#39;.join(repr(arg) for arg in args) print(&#39;[%0.8fs] %s(%s) -&gt; %r&#39;%(elapsed, name, arg_str, result)) return result return clocked @clock def factorial(n): &quot;&quot;&quot; Calculates the factorial of n recursively. &quot;&quot;&quot; return 1 if n &lt; 2 else n*factorial(n-1) . factorial.__name__, factorial.__doc__ . (&#39;factorial&#39;, &#39; n Calculates the factorial of n recursively. n &#39;) . Two of the most interesting decorators in the std lib are lru_cache and singledispatch. . Memoization with functools.lru_cache . The lru_cache implements memoization ie storing the return value of expensive functions so that they can be used later. lru -&gt; Least Recently Used, meaning that the growth of the cache is limited by discarding the entries that have not been read for a while. Lets see this in action! . @clock def fibonacci(n): if n &lt; 2: return n return fibonacci(n-2) + fibonacci(n-1) if __name__==&#39;__main__&#39;: print(fibonacci(6)) . [0.00000188s] fibonacci(0) -&gt; 0 [0.00000524s] fibonacci(1) -&gt; 1 [0.00081197s] fibonacci(2) -&gt; 1 [0.00000195s] fibonacci(1) -&gt; 1 [0.00003227s] fibonacci(0) -&gt; 0 [0.00000245s] fibonacci(1) -&gt; 1 [0.00052311s] fibonacci(2) -&gt; 1 [0.00085437s] fibonacci(3) -&gt; 2 [0.00176118s] fibonacci(4) -&gt; 3 [0.00000189s] fibonacci(1) -&gt; 1 [0.00000182s] fibonacci(0) -&gt; 0 [0.00000189s] fibonacci(1) -&gt; 1 [0.00011098s] fibonacci(2) -&gt; 1 [0.00016867s] fibonacci(3) -&gt; 2 [0.00000140s] fibonacci(0) -&gt; 0 [0.00000188s] fibonacci(1) -&gt; 1 [0.00023110s] fibonacci(2) -&gt; 1 [0.00000140s] fibonacci(1) -&gt; 1 [0.00000140s] fibonacci(0) -&gt; 0 [0.00000147s] fibonacci(1) -&gt; 1 [0.00002528s] fibonacci(2) -&gt; 1 [0.00009254s] fibonacci(3) -&gt; 2 [0.00073033s] fibonacci(4) -&gt; 3 [0.00093189s] fibonacci(5) -&gt; 5 [0.00273435s] fibonacci(6) -&gt; 8 8 . As you can see there is a lot of wasted cycles. . import functools @functools.lru_cache() @clock def fibonacci(n): if n &lt; 2: return n else : return fibonacci(n-1) + fibonacci(n-2) fibonacci(6) . [0.00000189s] fibonacci(1) -&gt; 1 [0.00000237s] fibonacci(0) -&gt; 0 [0.00014730s] fibonacci(2) -&gt; 1 [0.00018312s] fibonacci(3) -&gt; 2 [0.00021742s] fibonacci(4) -&gt; 3 [0.00025066s] fibonacci(5) -&gt; 5 [0.00028509s] fibonacci(6) -&gt; 8 . 8 . Try it with really high number to see how much difference it makes (something like 30 will give u really big differences) . other than making silly recursinve functions faster, they are also super helpfull in applications that fetches info from the web . They have additional arguments . lru_cache(maxsize=128, typed=True) . Generic Functions with singledispatch . Now this one is a personal favorite of mine. Let take an example, say you want to generate HTML displays for different Python objects. . import html def htmlize(obj): content = html.escape(repr(obj)) return &#39;&lt;pre&gt;{}&lt;/pre&gt;&#39;.format(content) . htmlize({1, 2, 4}), htmlize(1) . (&#39;&lt;pre&gt;{1, 2, 4}&lt;/pre&gt;&#39;, &#39;&lt;pre&gt;1&lt;/pre&gt;&#39;) . What we want to build is a htmlize that displays according to the data that is passed. Since we have no function overloading in Python we cannot create different function for each signature. What we usally do is create a dispatch function with many if/elif/else statements to handle it. . But another way is to use functools.singledispatch. If a function is decorated with this, it becomes a generic function. See the example to know how this is implemented. . from functools import singledispatch from collections import abc import numbers import html @singledispatch # this marks the base function that handles the obj type. def htmlize(obj): content = html.escape(repr(obj)) return &#39;&lt;pre&gt;{}&lt;/pre&gt;&#39;.format(content) @htmlize.register(str) # each special func is decorated using the base func def _(text): # here the name is irrelevent, hence _ is a good choice content = html.escape(text).replace(&#39; n&#39;, &#39;&lt;br&gt; n&#39;) return &#39;&lt;p&gt;{0}&lt;/p&gt;&#39;.format(content) @htmlize.register(numbers.Integral) # create new funcs for other types def _(n): return &#39;&lt;pre&gt;{0} (0x{0:x})&lt;/pre&gt;&#39;.format(n) @htmlize.register(tuple) @htmlize.register(abc.MutableSequence) # stack together different types that support the same func def _(seq): inner = &#39;&lt;/li&gt; n&lt;li&gt;&#39;.join(htmlize(item) for item in seq) return &#39;&lt;ul&gt; n&lt;li&gt;&#39; + inner + &#39;&lt;/li&gt; n&lt;/ul&gt;&#39; . print(htmlize(&#39;hai&#39;)) . &lt;p&gt;hai&lt;/p&gt; . print(htmlize(1)) . &lt;pre&gt;1 (0x1)&lt;/pre&gt; . print(htmlize((&#39;this&#39;, &#39;is&#39;, &#39;awesome&#39;))) . &lt;ul&gt; &lt;li&gt;&lt;p&gt;this&lt;/p&gt;&lt;/li&gt; &lt;li&gt;&lt;p&gt;is&lt;/p&gt;&lt;/li&gt; &lt;li&gt;&lt;p&gt;awesome&lt;/p&gt;&lt;/li&gt; &lt;/ul&gt; . tip: When possible, register the specialized functions to handle ABCs (abstract classes) such as numbers.Integral and abc.MutableSequence instead of concrete implementations like int and list . This allows your code to support a greater variety of compatible types. For example, a Python extension can provide alternatives to the int type with fixed bit lengths as subclasses of numbers.Integral. . A notable feature is that additional mechanisms to handle some datatypes can be registered from anywhere in the system, in any module. . Stacked Decorators . When 2 or more decorators are used on after another they are said to be stacked decorators. . @d1 @d2 def func() #becomes -&gt; func = d1(d2(func)) . Parameterized Decorators . passing arguments to decorators. Lets look at a registeration module and build it from there. . registry = [] def register(func): print(&#39;running register(%s)&#39; % func) registry.append(func) return func @register def f1(): print(&#39;running f1()&#39;) print(&#39;running main()&#39;) print(&#39;registry -&gt;&#39;, registry) f1() . running register(&lt;function f1 at 0x7fa0b82a5b90&gt;) running main() registry -&gt; [&lt;function f1 at 0x7fa0b82a5b90&gt;] running f1() . Now let make it easy to enable or diable the function registration by adding a paramter active. Conceptually, the new register is not a decorator but a decorator factory. When called, it returns the actual decorator that will be applied to the target function. . registry = set() def register(active=True): # this is now a decorator function def decorate(func): print(&#39;running register(active=%s)-&gt;decorate(%s)&#39; % (active, func)) if active: registry.add(func) else: registry.discard(func) return func return decorate @register(active=False) def f1(): print(&#39;running f1()&#39;) @register() def f2(): print(&#39;running f2()&#39;) def f3(): print(&#39;running f3()&#39;) . running register(active=False)-&gt;decorate(&lt;function f1 at 0x7f8b00b300d0&gt;) running register(active=True)-&gt;decorate(&lt;function f2 at 0x7f8b00b30310&gt;) . registry . {&lt;function __main__.f2()&gt;} . # it will actually look register()(f3) . running register(active=True)-&gt;decorate(&lt;function f3 at 0x7f8b00b30040&gt;) . &lt;function __main__.f3()&gt; . registry . {&lt;function __main__.f2()&gt;, &lt;function __main__.f3()&gt;} . Now lets revisit the clock decorator and add an extra feature. Users may pass a format string to control the output of the decorated function. . import time DEFAULT_FMT = &#39;[{elapsed:0.8f}s] {name}({args}) -&gt; {result}&#39; def clock(fmt=DEFAULT_FMT): def decorate(func): def clocked(*_args): t0 = time.time() _result = func(*_args) elapsed = time.time() - t0 name = func.__name__ args = &#39;, &#39;.join(repr(arg) for arg in _args) result = repr(_result) print(fmt.format(**locals())) return _result return clocked return decorate . @clock() def snooze(seconds): time.sleep(seconds) for i in range(3): snooze(1) . [1.00125384s] snooze(1) -&gt; None [1.00108457s] snooze(1) -&gt; None [1.00108957s] snooze(1) -&gt; None . @clock(&#39;{name}: {elapsed}s&#39;) def snooze(seconds): time.sleep(seconds) for i in range(3): snooze(.123) . snooze: 0.12353754043579102s snooze: 0.12320995330810547s snooze: 0.12340807914733887s . Note: It&#39;s advisable to implement decorators as classes with __call__ function than the way it is shown in this notebook. This is best for non-trivial examples. .",
            "url": "https://fluentpython.jjmachan.in/2021/10/12/ch7-function-decorators-and-closures.html",
            "relUrl": "/2021/10/12/ch7-function-decorators-and-closures.html",
            "date": " • Oct 12, 2021"
        }
        
    
  
    
        ,"post1": {
            "title": "Chapter 6: Design Patterns with First-Class Functions",
            "content": "Your language of choice has a lot impact on the Design patterns you choose and how exactly they are implemented. Since in python, functions are first class object, that brings about a lot of change in how you implement the classic design patterns. You can use function . from abc import ABC, abstractmethod from collections import namedtuple Customer = namedtuple(&#39;Customer&#39;, &#39;name fidelity&#39;) class LineItem: def __init__(self, product, quantity, price): self.product = product self.quantity = quantity self.price = price def total(self): return self.price * self.quantity class Order: # the Context def __init__(self, customer, cart, promotion=None): self.customer = customer self.cart = list(cart) self.promotion = promotion def total(self): if not hasattr(self, &#39;__total&#39;): self.__total = sum(item.total() for item in self.cart) return self.__total def due(self): if self.promotion is None: discount = 0 else: discount = self.promotion.discount(self) return self.total() - discount def __repr__(self): fmt = &#39;&lt;Order total: {:.2f} due: {:.2f}&gt;&#39; return fmt.format(self.total(), self.due()) class Promotion(ABC): # the Strategy: an abstract base class @abstractmethod def discount(self, order): &quot;&quot;&quot;Return discount as a positive dollar amount&quot;&quot;&quot; class FidelityPromo(Promotion): # first Concrete Strategy &quot;&quot;&quot;5% discount for customers with 1000 or more fidelity points&quot;&quot;&quot; def discount(self, order): return order.total() * .05 if order.customer.fidelity &gt;= 1000 else 0 class BulkItemPromo(Promotion): # second Concrete Strategy &quot;&quot;&quot;10% discount for each LineItem with 20 or more units&quot;&quot;&quot; def discount(self, order): discount = 0 for item in order.cart: if item.quantity &gt;= 20: discount += item.total() * .1 return discount class LargeOrderPromo(Promotion): # third Concrete Strategy &quot;&quot;&quot;7% discount for orders with 10 or more distinct items&quot;&quot;&quot; def discount(self, order): distinct_items = {item.product for item in order.cart} if len(distinct_items) &gt;= 10: return order.total() * .07 return 0 . joe = Customer(&#39;John Doe&#39;, 0) ann = Customer(&#39;Ann Smith&#39;, 1100) cart = [LineItem(&#39;banana&#39;, 4, .5), LineItem(&#39;apple&#39;, 10, 1.5), LineItem(&#39;watermellon&#39;, 5, 5.0)] Order(joe, cart, FidelityPromo()) . &lt;Order total: 42.00 due: 42.00&gt; . Order(ann, cart, FidelityPromo()) . &lt;Order total: 42.00 due: 39.90&gt; . banana_cart = [LineItem(&#39;banana&#39;, 30, .5), LineItem(&#39;apple&#39;, 10, 1.5)] Order(joe, banana_cart, BulkItemPromo()) . &lt;Order total: 30.00 due: 28.50&gt; . long_order = [LineItem(str(item_code), 1, 1.0) for item_code in range(10)] Order(joe, long_order, LargeOrderPromo()) . &lt;Order total: 10.00 due: 9.30&gt; . Order(joe, cart, LargeOrderPromo()) . &lt;Order total: 42.00 due: 42.00&gt; . This works very well but let&#39;s modify it to work better using functions as objects. Here the strategy instances (classes implementing promo codes) have no state and work as plain old functions. Hence we can refractor them out into functions . from collections import namedtuple Customer = namedtuple(&#39;Customer&#39;, &#39;name fidelity&#39;) class LineItem: def __init__(self, product, quantity, price): self.product = product self.quantity = quantity self.price = price def total(self): return self.price * self.quantity class Order: def __init__(self, customer, cart, promotion=None): self.customer = customer self.cart = list(cart) self.promotion = promotion def total(self): if not hasattr(self, &#39;__total&#39;): self.__total = sum(item.total() for item in self.cart) return self.__total def due(self): if self.promotion is None: discount = 0 else: discount = self.promotion(self) return self.total() - discount def __repr__(self): fmt = &#39;&lt;Order total: {:.2f} due: {:.2f}&gt;&#39; return fmt.format(self.total(), self.due()) def fidelity_promo(order): &quot;&quot;&quot;5% discount for customers with 1000 or more fidelity points&quot;&quot;&quot; return order.total() * .05 if order.customer.fidelity &gt;= 1000 else 0 def bulk_item_promo(order): &quot;&quot;&quot;10% discount for each LineItem with 20 or more units&quot;&quot;&quot; discount = 0 for item in order.cart: if item.quantity &gt;= 20: discount += item.total() * .1 return discount def large_order_promo(order): &quot;&quot;&quot;7% discount for orders with 10 or more distinct items&quot;&quot;&quot; distinct_items = {item.product for item in order.cart} if len(distinct_items) &gt;= 10: return order.total() * .07 return 0 . joe = Customer(&#39;John Doe&#39;, 0) ann = Customer(&#39;Ann Smith&#39;, 1100) cart = [LineItem(&#39;banana&#39;, 4, .5), LineItem(&#39;apple&#39;, 1000, 1.5), LineItem(&#39;watermellon&#39;, 5, 5.0)] Order(joe, cart, fidelity_promo) . &lt;Order total: 1527.00 due: 1527.00&gt; . As you can see the proper use of functions eleminates the use of classes with single methods. these stategies are also reusable and can be called from the module from which it is defined. . Now lets implement a meta stategy to find the best promo available. . promos = [fidelity_promo, bulk_item_promo, large_order_promo] . def best_promo(order): &quot;&quot;&quot;Select the best discount available&quot;&quot;&quot; return max(promo(order) for promo in promos) . Order(joe, cart, best_promo) . &lt;Order total: 1527.00 due: 1377.00&gt; . This works quite well but there is a bit of duplication involved. Each time we create a new function we have to add it into the promos list. If it&#39;s not added then it does not get used. . Now lets see a couple of solutions to fix that. . def test_promo(self): pass # somewhat hackish sol using the globals() promos = [globals()[name] for name in globals() if name.endswith(&#39;_promo&#39;) and name != &#39;best_promo&#39;] . promos . [&lt;function __main__.fidelity_promo(order)&gt;, &lt;function __main__.bulk_item_promo(order)&gt;, &lt;function __main__.large_order_promo(order)&gt;, &lt;function __main__.test_promo(self)&gt;] . Another way is to move all the module to a new module and using inspect get all the members. . import inspect class promotions: def test_promo(self): pass promos = [func for name, func in inspect.getmembers(promotions, inspect.isfunction)] . promos . [&lt;function __main__.promotions.test_promo(self)&gt;] . Now another possiblity is to use decorators which IMO is a must cleaner implementation. (More on Chapter 7) . Command . Command is another design pattern that can be simplified by the use of functions passed as arguments. The goal of the Comamand is to decouple the object than invokes an operation (the Invoker) from the provider object that implements it (the Receiver). . Now simple way to implement this is with callbacks. Each Command can be implemented as a class which contains the list of commands that has to be executed. Defining a __call__ in it will create a callable object. . class MacroCommand: &quot;&quot;&quot; A command that executes a list of commands&quot;&quot;&quot; def __init__(self, commands): self.commands = list(commands) def __call__(self): for command in self.commands: command() .",
            "url": "https://fluentpython.jjmachan.in/2021/09/23/ch6-design-patterns-with-first-class-functions.html",
            "relUrl": "/2021/09/23/ch6-design-patterns-with-first-class-functions.html",
            "date": " • Sep 23, 2021"
        }
        
    
  
    
        ,"post2": {
            "title": "Chapter 5: First-Class Functions",
            "content": "Funtion in python are a first class objects. Now what is a first class object? A program entity is a first class object if it can be: . Created at runtime | Assigned to a variable or element in a data structure | Passed as argument to a function | returned as argument to a function | . def factorial(n): &quot;&quot;&quot;returns n!&quot;&quot;&quot; return 1 if n &lt; 2 else n*factorial(n-1) . factorial(42) . 1405006117752879898543142606244511569936384000000000 . factorial.__doc__ . &#39;returns n!&#39; . type(factorial) . function . dir(factorial) . [&#39;__annotations__&#39;, &#39;__call__&#39;, &#39;__class__&#39;, &#39;__closure__&#39;, &#39;__code__&#39;, &#39;__defaults__&#39;, &#39;__delattr__&#39;, &#39;__dict__&#39;, &#39;__dir__&#39;, &#39;__doc__&#39;, &#39;__eq__&#39;, &#39;__format__&#39;, &#39;__ge__&#39;, &#39;__get__&#39;, &#39;__getattribute__&#39;, &#39;__globals__&#39;, &#39;__gt__&#39;, &#39;__hash__&#39;, &#39;__init__&#39;, &#39;__init_subclass__&#39;, &#39;__kwdefaults__&#39;, &#39;__le__&#39;, &#39;__lt__&#39;, &#39;__module__&#39;, &#39;__name__&#39;, &#39;__ne__&#39;, &#39;__new__&#39;, &#39;__qualname__&#39;, &#39;__reduce__&#39;, &#39;__reduce_ex__&#39;, &#39;__repr__&#39;, &#39;__setattr__&#39;, &#39;__sizeof__&#39;, &#39;__str__&#39;, &#39;__subclasshook__&#39;] . fact = factorial fact . &lt;function __main__.factorial(n)&gt; . fact(5) . 120 . map(factorial, range(11)) . &lt;map at 0x7eff0c23fc40&gt; . list(map(factorial, range(5))) . [1, 1, 2, 6, 24] . Higher-Order Functions . Having first-class functions enables programming in a functional style. One of the hall-marks of functional programming is the use of Higher-order functions. A function that takes another function as argument or returns a function is called a higher order function. This can be seen in the map example above or the sorted function which has a keyword argumnet key which takes a function. . fruits = [&#39;strawberry&#39;, &#39;fig&#39;, &#39;apple&#39;, &#39;cherry&#39;, &#39;raspberry&#39;, &#39;banana&#39;] sorted(fruits, key=len) . [&#39;fig&#39;, &#39;apple&#39;, &#39;cherry&#39;, &#39;banana&#39;, &#39;raspberry&#39;, &#39;strawberry&#39;] . def reverse(word): return word[::-1] reverse(&#39;testing&#39;) . &#39;gnitset&#39; . sorted(fruits, key=reverse) . [&#39;banana&#39;, &#39;apple&#39;, &#39;fig&#39;, &#39;raspberry&#39;, &#39;strawberry&#39;, &#39;cherry&#39;] . map, filter and reduce are the best-know higher order functions. But there are better alternatives to these and we will see them below. . listcomps and genexps replace the functionalities of map and filter and in most cases they are more readable. . list(map(fact, range(6))) . [1, 1, 2, 6, 24, 120] . [fact(n) for n in range(6)] . [1, 1, 2, 6, 24, 120] . list(map(fact, filter(lambda n: n%2, range(6)))) . [1, 6, 120] . [fact(n) for n in range(6) if n%2] . [1, 6, 120] . In python3 map and filter return generators so their direct substituion is genexps. genexps are more performant for large lists too, so use that when necessary. . from functools import reduce from operator import add reduce(add, range(100)) . 4950 . sum(range(100)) . 4950 . There is also all(iterable) and any(iterable) that also have a reducing behavious and built in. . all([0, 0, 0, 1]), all([1, 1, 1, 1,]) . (False, True) . any([0, 0, 0, 0]), any([0, 0, 0, 1]) . (False, True) . Anonymous Functions . using the lambda keyword, you can create a anonymous function within a python expression. the lambda function cannot be used to create complex functions with while try etc. but its best use is in the context of arguments lists. . for example lets rewrite the reverse function we saw earlier using lambda. . fruits = [&#39;strawberry&#39;, &#39;fig&#39;, &#39;apple&#39;, &#39;cherry&#39;, &#39;raspberry&#39;, &#39;banana&#39;] sorted(fruits, key=lambda word: word[::-1]) . [&#39;banana&#39;, &#39;apple&#39;, &#39;fig&#39;, &#39;raspberry&#39;, &#39;strawberry&#39;, &#39;cherry&#39;] . the lambda syntax is just syntatic sugar to create a &quot;callable object&quot; which is exactly what a function is. . The Seven Flabors of Callable Objects . the call operator (ie ()) can be applied to other objects as well. To check if an object is callable use callable() fn. There are 7 callable types definied in the Python Data Model . User-defined functions - created with def or lambda | Built-in functions - fn implementation in C. eg len or time.strftime | Built-in methods - methods implemented in C like dict.get | Methods - functions defined in the body of a class | Classes - creating new instance of a class calls the __new__ and __init__ fns | Class instances - if a class defines __call__ method | Generator functions - fns/methods that have yeild keyword | callable(map) . True . User-defined Callable types . not only are Python functions real object, arbitary Python objects may also be made to behave like functions by implementing a __call__ instance method. This helps create function-like objects that have some internal state that must be kept across invocations. . import random class BingoCage: def __init__(self, items): self._items = list(items) random.shuffle(self._items) def pick(self): try: return self._items.pop() except IndexError: raise LookupError(&#39;pick from empty BingoCage&#39;) def __call__(self): return self.pick() . bingo = BingoCage(range(3)) bingo.pick() . 2 . bingo() . 0 . Function Introspection . function, as we mentioned earlier are first-class objects. Now lets look at the factors that make its so. . &gt; &gt; dir(factorial) . The __dict__ attribute:Like instances of plain user-defined class, a function uses __dict__ attribute to store user attributes assigned to it. Looking closer at attributes that are specific to functions. To see the detailed explaination of each attribute ref Table-5.1 pg 148. . class C: pass obj = C() def func(): pass sorted(set(dir(func)) - set(dir(obj))) . [&#39;__annotations__&#39;, &#39;__call__&#39;, &#39;__closure__&#39;, &#39;__code__&#39;, &#39;__defaults__&#39;, &#39;__get__&#39;, &#39;__globals__&#39;, &#39;__kwdefaults__&#39;, &#39;__name__&#39;, &#39;__qualname__&#39;] . From Positional to Keywork-Only Parameters . Python has an extreamly flexible parameter handling mechanism as you can see with the exaple below. . def tag(name, *content, cls=None, **attrs): &quot;&quot;&quot;Generates one or more HTML tags&quot;&quot;&quot; if cls is not None: attrs[&#39;class&#39;] = cls if attrs: attr_str = &#39; &#39;.join(&#39;%s=&quot;%s&quot;&#39; % (attr, value) for attr, value in sorted(attrs.items())) else: attr_str = &#39;&#39; if content: return &#39; n&#39;.join(&#39;&lt;%s%s&gt;%s&lt;/%s&gt;&#39; % (name, attr_str, c, name) for c in content) else: return &#39;&lt;%s%s /&gt;&#39; % (name, attr_str) . tag(&#39;br&#39;) . &#39;&lt;br /&gt;&#39; . tag(&#39;p&#39;, &#39;hello&#39;) . &#39;&lt;p&gt;hello&lt;/p&gt;&#39; . tag(&#39;p&#39;, &#39;hello&#39;, &#39;world&#39;) . &#39;&lt;p&gt;hello&lt;/p&gt; n&lt;p&gt;world&lt;/p&gt;&#39; . tag(&#39;p&#39;, &#39;hello&#39;, id=33) . &#39;&lt;pid=&#34;33&#34;&gt;hello&lt;/p&gt;&#39; . my_tag = {&#39;name&#39;: &#39;img&#39;, &#39;title&#39;: &#39;Sunset Boulevard&#39;, &#39;src&#39;: &#39;sunset.jpg&#39;, &#39;cls&#39;: &#39;framed&#39;} . tag(**my_tag) . &#39;&lt;imgclass=&#34;framed&#34; src=&#34;sunset.jpg&#34; title=&#34;Sunset Boulevard&#34; /&gt;&#39; . Retrieving Information about Parameters . An interesting application of function introspection can be seen in Bobo HTTP micro-framework. . import bobo @bobo.query(&#39;/&#39;) def hello(person): return &#39;Hello %s!&#39; % person . What&#39;s special about this is that the decorator @bobo.query() interospects the hello function and understands that it expects one argument. It then parses the response and return the person to the function. All this without the user having to work with the response. . This is achieved using various attributes like __defaults__ and __kwdefaults__, __code__ etc. Lets see another example to see better. . def clip(text, max_len=80): &quot;&quot;&quot; Return text clipped at the last space before or afte max_len. &quot;&quot;&quot; end = None if len(text) &gt; max_len: space_before = text.rfind(&#39; &#39;, 0, max_len) if space_before &gt;= 0: end = space_before else: space_after = text.rfind(&#39; &#39;, max_len) if space_after &gt;= 0: end = space_after if end is None: end = len(text) return text[:end].rstrip() . clip.__defaults__ . (80,) . clip.__code__ . &lt;code object clip at 0x7eff0c1ce920, file &#34;&lt;ipython-input-50-c90bf6018cd7&gt;&#34;, line 1&gt; . clip.__code__.co_varnames . (&#39;text&#39;, &#39;max_len&#39;, &#39;end&#39;, &#39;space_before&#39;, &#39;space_after&#39;) . clip.__code__.co_argcount . 2 . clip.__defaults__, clip.__name__, clip.__kwdefaults__ . ((80,), &#39;clip&#39;, None) . Now this is kind off a messy way to learn about the functions but fortunately there is the inspect module. . from inspect import signature sig = signature(clip) sig . &lt;Signature (text, max_len=80)&gt; . str(sig) . &#39;(text, max_len=80)&#39; . for name, param in sig.parameters.items(): print(param.kind, &#39;:&#39;, name, &#39;=&#39;, param.default) . POSITIONAL_OR_KEYWORD : text = &lt;class &#39;inspect._empty&#39;&gt; POSITIONAL_OR_KEYWORD : max_len = 80 . as you can see this is a much better way to parse the argument info. signature also has a annotation attribute to give info about annotations. . inspect.Signature object also has a bind function that takes any number of arguments and binds them to the parameters. This can be used in frameworks to do validation of arguments before invocations. This is the same machinery the interpreter uses to bind arguments to formal parameters in function calls . sig = signature(tag) my_tag = {&#39;name&#39;: &#39;img&#39;, &#39;title&#39;: &#39;Sunset Boulevard&#39;, &#39;src&#39;: &#39;sunset.jpg&#39;, &#39;cls&#39;: &#39;framed&#39;} bound_args = sig.bind(**my_tag) bound_args . &lt;BoundArguments (name=&#39;img&#39;, cls=&#39;framed&#39;, attrs={&#39;title&#39;: &#39;Sunset Boulevard&#39;, &#39;src&#39;: &#39;sunset.jpg&#39;})&gt; . for name, value in bound_args.arguments.items(): print(name, &#39;=&#39;, value) . name = img cls = framed attrs = {&#39;title&#39;: &#39;Sunset Boulevard&#39;, &#39;src&#39;: &#39;sunset.jpg&#39;} . del my_tag[&#39;name&#39;] bound_args = sig.bind(**my_tag) . TypeErrorTraceback (most recent call last) &lt;ipython-input-67-26e5f49b96e2&gt; in &lt;module&gt; 1 del my_tag[&#39;name&#39;] -&gt; 2 bound_args = sig.bind(**my_tag) /usr/lib/python3.8/inspect.py in bind(self, *args, **kwargs) 3023 if the passed arguments can not be bound. 3024 &#34;&#34;&#34; -&gt; 3025 return self._bind(args, kwargs) 3026 3027 def bind_partial(self, /, *args, **kwargs): /usr/lib/python3.8/inspect.py in _bind(self, args, kwargs, partial) 2938 msg = &#39;missing a required argument: {arg!r}&#39; 2939 msg = msg.format(arg=param.name) -&gt; 2940 raise TypeError(msg) from None 2941 else: 2942 # We have a positional argument to process TypeError: missing a required argument: &#39;name&#39; . Function Annotations . You have seen above how the Python data model with the help of inspect exposes the same machinery the interpreter uses to bind arguments to formal parameters in function call. Function annotation enhances the possible uses of this. . def clip(text:str, max_len:&#39;int&gt;0&#39; = 0) -&gt; str: &quot;&quot;&quot; Return text clipped at the last space before or afte max_len. &quot;&quot;&quot; end = None if len(text) &gt; max_len: space_before = text.rfind(&#39; &#39;, 0, max_len) if space_before &gt;= 0: end = space_before else: space_after = text.rfind(&#39; &#39;, max_len) if space_after &gt;= 0: end = space_after if end is None: end = len(text) return text[:end].rstrip() . # its not used by the python interpreter sig = signature(clip) sig.return_annotation . str . for param in sig.parameters.values(): note = repr(param.annotation).ljust(13) print(note, &#39;:&#39;, param.name, &#39;=&#39;, param.default) . &lt;class &#39;str&#39;&gt; : text = &lt;class &#39;inspect._empty&#39;&gt; &#39;int&gt;0&#39; : max_len = 0 . These annotation can be used with tools like mypy to bring the benifits of static type checking into python. . Packages for Functional Programming . Althou python is not a functional language, a functional coding style can be brought in by the operator &amp; functools libs. . operator module . Provides some arithmetic operators as a functions for when you need em. . %%timeit from functools import reduce def fact(n): return reduce(lambda a, b: a*b, range(1, n+1)) fact(5) . 1.03 µs ± 15.1 ns per loop (mean ± std. dev. of 7 runs, 1000000 loops each) . %%timeit # operator has these functions for you! from operator import mul def fact(n): return reduce(mul, range(1, n+1)) fact(5) . 820 ns ± 2.44 ns per loop (mean ± std. dev. of 7 runs, 1000000 loops each) . Another group of one-trick lambdas that operator replaces are functions to pick items from sequences or read attributes from objects: itemgetter and attrgetter actually build custom functions to do that. . metro_data = [ (&#39;Tokyo&#39;, &#39;JP&#39;, 36.933, (35.689722, 139.691667)), (&#39;Delhi NCR&#39;, &#39;IN&#39;, 21.935, (28.613889, 77.208889)), (&#39;Mexico City&#39;, &#39;MX&#39;, 20.142, (19.433333, -99.133333)), (&#39;New York-Newark&#39;, &#39;US&#39;, 20.104, (40.808611, -74.020386)), (&#39;Sao Paulo&#39;, &#39;BR&#39;, 19.649, (-23.547778, -46.635833)), ] from operator import itemgetter # sort based of tuple[2] for city in sorted(metro_data, key=itemgetter(2)): print(city) . (&#39;Sao Paulo&#39;, &#39;BR&#39;, 19.649, (-23.547778, -46.635833)) (&#39;New York-Newark&#39;, &#39;US&#39;, 20.104, (40.808611, -74.020386)) (&#39;Mexico City&#39;, &#39;MX&#39;, 20.142, (19.433333, -99.133333)) (&#39;Delhi NCR&#39;, &#39;IN&#39;, 21.935, (28.613889, 77.208889)) (&#39;Tokyo&#39;, &#39;JP&#39;, 36.933, (35.689722, 139.691667)) . cc_name = itemgetter(1, 0) for city in metro_data: print(cc_name(city)) . (&#39;JP&#39;, &#39;Tokyo&#39;) (&#39;IN&#39;, &#39;Delhi NCR&#39;) (&#39;MX&#39;, &#39;Mexico City&#39;) (&#39;US&#39;, &#39;New York-Newark&#39;) (&#39;BR&#39;, &#39;Sao Paulo&#39;) . itemgetter supports seqences and mappings (any object with a __getitem__ . Simalar to that is attrgetter, which creates a functions to extract ojbect attributes by name. It will also get attributes that require the .(dot) . from collections import namedtuple LatLong = namedtuple(&#39;LatLong&#39;, &#39;lat long&#39;) Metropolis = namedtuple(&#39;Metropolis&#39;, &#39;name cc pop coord&#39;) metro_areas = [Metropolis(name, cc, pop, LatLong(lat, long)) for name, cc, pop, (lat, long) in metro_data] metro_areas[0] . Metropolis(name=&#39;Tokyo&#39;, cc=&#39;JP&#39;, pop=36.933, coord=LatLong(lat=35.689722, long=139.691667)) . metro_areas[0].coord.lat . 35.689722 . from operator import attrgetter name_lat = attrgetter(&#39;name&#39;, &#39;coord.lat&#39;) for city in sorted(metro_areas, key=attrgetter(&#39;coord.lat&#39;)): print(name_lat(city)) . (&#39;Sao Paulo&#39;, -23.547778) (&#39;Mexico City&#39;, 19.433333) (&#39;Delhi NCR&#39;, 28.613889) (&#39;Tokyo&#39;, 35.689722) (&#39;New York-Newark&#39;, 40.808611) . import operator [name for name in dir(operator) if not name.startswith(&#39;_&#39;)] . [&#39;abs&#39;, &#39;add&#39;, &#39;and_&#39;, &#39;attrgetter&#39;, &#39;concat&#39;, &#39;contains&#39;, &#39;countOf&#39;, &#39;delitem&#39;, &#39;eq&#39;, &#39;floordiv&#39;, &#39;ge&#39;, &#39;getitem&#39;, &#39;gt&#39;, &#39;iadd&#39;, &#39;iand&#39;, &#39;iconcat&#39;, &#39;ifloordiv&#39;, &#39;ilshift&#39;, &#39;imatmul&#39;, &#39;imod&#39;, &#39;imul&#39;, &#39;index&#39;, &#39;indexOf&#39;, &#39;inv&#39;, &#39;invert&#39;, &#39;ior&#39;, &#39;ipow&#39;, &#39;irshift&#39;, &#39;is_&#39;, &#39;is_not&#39;, &#39;isub&#39;, &#39;itemgetter&#39;, &#39;itruediv&#39;, &#39;ixor&#39;, &#39;le&#39;, &#39;length_hint&#39;, &#39;lshift&#39;, &#39;lt&#39;, &#39;matmul&#39;, &#39;methodcaller&#39;, &#39;mod&#39;, &#39;mul&#39;, &#39;ne&#39;, &#39;neg&#39;, &#39;not_&#39;, &#39;or_&#39;, &#39;pos&#39;, &#39;pow&#39;, &#39;rshift&#39;, &#39;setitem&#39;, &#39;sub&#39;, &#39;truediv&#39;, &#39;truth&#39;, &#39;xor&#39;] . Similar to itemgetter and attrgetter, methodcaller also returns a function that calls a method by name on the object given as argument. . from operator import methodcaller s = &#39;The time has home&#39; upcase = methodcaller(&#39;upper&#39;) upcase(s) . &#39;THE TIME HAS HOME&#39; . hiphenate = methodcaller(&#39;replace&#39;, &#39; &#39;, &#39;-&#39;) hiphenate(s) . &#39;The-time-has-home&#39; . Here, in the last case you can see methodcaller froze 2 arguments to the replace function. . functools.partial . The functools module brings together a handful of higher-order functions. The best know function is probably reduce. The other most popular functions are partial and partialmethod . from operator import mul from functools import partial triple = partial(mul, 3) triple(7) . 21 . [triple(n) for n in range(10)] . [0, 3, 6, 9, 12, 15, 18, 21, 24, 27] . partial takes a callable function name and any number of positional or keyword arguments and generates a new function with the args in place. This is effective in situations where you want to pass a callback to an API that expects fewer args that that is there in the function. partial takes a callable as first argument, followed by an arbitrary number of positional and keyword arguments to bind. . partialmethod does the same thing but for methods. .",
            "url": "https://fluentpython.jjmachan.in/2021/09/16/ch5-first-class-functions.html",
            "relUrl": "/2021/09/16/ch5-first-class-functions.html",
            "date": " • Sep 16, 2021"
        }
        
    
  
    
        ,"post3": {
            "title": "Chapter 4: Text versus Bytes",
            "content": "Charecter Issue . Now the best definition of what a Charater is, is its Unicode representation. The Unicode standard explicitly seperates the identity of charaters from its bytes representation. . The identity of the character is its code point (ie in the form U+000000). For example A is U+0041. . The actual bytes representation depends on the encoding that is used. If we use UTF-8 encoding, the byte representation of A is x41 but if we use UTF-16LE it is x41 x00 . Coverting from code points to bytes is called encoding and from bytes to code points is called decoding . s = &#39;café&#39; len(s) . 4 . b = s.encode(&#39;utf_8&#39;) b . b&#39;caf xc3 xa9&#39; . len(b), b.decode(&#39;utf8&#39;) . (5, &#39;café&#39;) . Byte Essentials . There are 2 basic build-in types for binary sequence, the immutable bytes type and the mutable bytearray. Each item in both is an integer from 0-255 . cafe = bytes(&#39;café&#39;, encoding=&#39;utf_8&#39;) cafe . b&#39;caf xc3 xa9&#39; . len(cafe) . 5 . cafe[0] . 99 . for i in range(len(cafe)): print(cafe[i]) . 99 97 102 195 169 . cafe[:1] . b&#39;c&#39; . cafe_arr = bytearray(cafe) cafe_arr . bytearray(b&#39;caf xc3 xa9&#39;) . cafe_arr[-1:] . bytearray(b&#39; xa9&#39;) . len(cafe_arr) . 5 . As you can see, even though the binary sequence is sequence of integers, they are displayed on each byte value. ASCII text and espace squences are displayed as its is while all other bytes use a hexadecimal escape sequence. . Both bytes and bytearray support every str method except those that do formatting ( format , format_map ) and a few others that depend on Unicode data, including case fold , isdecimal , isidentifier , isnumeric , isprintable , and encode . This means that you can use familiar string methods like endswith , replace , strip , translate , upper , and dozens of others with binary sequences—only using bytes and not str arguments. In addition, the regular expression functions in the re module also work on binary sequences, if the regex is compiled from a binary sequence instead of a str . . A byte or bytearray can be build in many ways like . using the constructors calling classmethods like byte.fromhex() | A str and an encoding keyword argument. | An iterable providing items with values from 0 to 255. | An object that implements the buffer protocol (e.g., bytes, bytearray, memory view, array.array); this copies the bytes from the source object to the newly created binary sequence. | b = bytes.fromhex(&#39;31 4B CE A9&#39;) print(b) # from an object that implements the buffer protocol import array # &#39;h&#39; denotes short integers nums = array.array(&#39;h&#39;, [-2, -1, 0, 1, 2]) octets = bytes(nums) print(octets) # from iterable b = bytes([65, 66, 67]) print(b) . b&#39;1K xce xa9&#39; b&#39; xfe xff xff xff x00 x00 x01 x00 x02 x00&#39; b&#39;ABC&#39; . Creating bytes/bytearray from buffer like source will always copy the bytes. In contrast memoryview objects let you share memory between both. To extract structured information from the binary source use the struct module. . Structs and Memory Views . To show the power of struct and memoryview let see an example were we took at the header of a gif file. . import struct # format of the bytes string (gif header) fmt = &#39;&lt;3s3sHH&#39; with open(&#39;leo.gif&#39;, &#39;rb&#39;) as fp: img = memoryview(fp.read()) header = img[:10] # creates a new memory view for only the headers bytes(header), header . (b&#39;GIF89aX x02 x90 x01&#39;, &lt;memory at 0x7f4d9050c400&gt;) . struct.unpack(fmt, header) . (b&#39;GIF&#39;, b&#39;89a&#39;, 600, 400) . del header del img . Encoder/Decoder . Pythons comes with 100s of basic encoders and decoder that are used to handle the different types commonly seen in the wild. Here is an example of a string encoded with 3 different codecs producing very different results. . for codec in [&#39;latin_1&#39;, &#39;utf_8&#39;, &#39;utf_16&#39;]: print(codec, &#39;El Niño&#39;.encode(codec), sep=&#39; t&#39;) . latin_1 b&#39;El Ni xf1o&#39; utf_8 b&#39;El Ni xc3 xb1o&#39; utf_16 b&#39; xff xfeE x00l x00 x00N x00i x00 xf1 x00o x00&#39; . Problems you might encounter . Python throws a encoding or decoding error UnicodeEnodeError or UnicodeDecodeError. We will look into how to handle these. It can also raise a SyntaxException when the source encoding is unexpected. . UnicodeEncodeError . Most not-utf codecs only handle a small subset of chars. This error is raised when converting from text to bytes and a char is not supported by the codec. . city = &#39;São Paulo&#39; city.encode(&#39;utf_8&#39;) . b&#39;S xc3 xa3o Paulo&#39; . city.encode(&#39;utf_16&#39;) . b&#39; xff xfeS x00 xe3 x00o x00 x00P x00a x00u x00l x00o x00&#39; . city.encode(&#39;cp437&#39;) . UnicodeEncodeErrorTraceback (most recent call last) &lt;ipython-input-4-064a572fd5b6&gt; in &lt;module&gt; -&gt; 1 city.encode(&#39;cp437&#39;) /usr/lib/python3.8/encodings/cp437.py in encode(self, input, errors) 10 11 def encode(self,input,errors=&#39;strict&#39;): &gt; 12 return codecs.charmap_encode(input,errors,encoding_map) 13 14 def decode(self,input,errors=&#39;strict&#39;): UnicodeEncodeError: &#39;charmap&#39; codec can&#39;t encode character &#39; xe3&#39; in position 1: character maps to &lt;undefined&gt; . The error argument however gives you options on how to handle these errors. . city.encode(&#39;cp437&#39;, errors=&#39;ignore&#39;) . b&#39;So Paulo&#39; . city.encode(&#39;cp437&#39;, errors=&#39;replace&#39;) . b&#39;S?o Paulo&#39; . city.encode(&#39;cp437&#39;, errors=&#39;xmlcharrefreplace&#39;) . b&#39;S&amp;#227;o Paulo&#39; . UnicodeDecodeError . Not every byte holds a valid ASCII char and not every byte sequence is a valid UTF-8 so if you assume a perticular encoding while converting a binary sequence to text you will get a UnicodeDecodeError if unexpected bytes are encountered. . But some leagacy enodings like cp1252 are able to decode any stream of bytes and hence no errors are generated even though the output might be junk. . octets = b&#39;Montr xe9al&#39; octets.decode(&#39;cp1252&#39;) . &#39;Montréal&#39; . octets.decode(&#39;iso8859_7&#39;) . &#39;Montrιal&#39; . octets.decode(&#39;utf_8&#39;) . UnicodeDecodeErrorTraceback (most recent call last) &lt;ipython-input-10-afaa3d3916c5&gt; in &lt;module&gt; -&gt; 1 octets.decode(&#39;utf_8&#39;) UnicodeDecodeError: &#39;utf-8&#39; codec can&#39;t decode byte 0xe9 in position 5: invalid continuation byte . octets.decode(&#39;utf_8&#39;, errors=&#39;replace&#39;) . &#39;Montr�al&#39; . SyntaxError when loading Modules with Unexpected Encodings . UTF-8 is the default encoding of Python 3 and if your code contains anything else and there is no encoding declaration it will throw an error. You can use the coding command to provide the expected encoding of the module. . # coding: cp1252 print(&#39;Olá, Mundo!&#39;) . Now coming to whether we should use non-ASCII identifier in source code is a personal choice. Preference should be given to people who is most likely to read and write the codebase more often and you should optimize for that. . How to Discover the Encoding of a Byte Sequence . in short, you can&#39;t, you have to be told. There are tools like Chardet - The Universal Charater Encoding Detector that works to detect the encoding with some assumptions. . BOM: A Useful Gremlin . You may notice an couple of extra bytes at the beginning of UTF-16 encoded sequence. The bytes &#39; xff xfe&#39; are used to denote little endian/big endian. . u16 = &#39;El Niño&#39;.encode(&#39;utf_16&#39;) u16 . b&#39; xff xfeE x00l x00 x00N x00i x00 xf1 x00o x00&#39; .",
            "url": "https://fluentpython.jjmachan.in/2021/09/08/ch4-text-vs-bytes.html",
            "relUrl": "/2021/09/08/ch4-text-vs-bytes.html",
            "date": " • Sep 8, 2021"
        }
        
    
  
    
        ,"post4": {
            "title": "Chapter 3: Dictionaries and Sets",
            "content": "Dictionaries are not just another dataset in python, they are an itergral part of the language. Hence Dicts are highly optimized, Dicts are implemented using hash tables. Sets are also build using hash tables and hence covered with this. . Generic Mapping Types - Mapping and MutableMapping . Both of these form the base classes for dicts and sets. The collection.abs module provides these. For implementing specialized mappings we often extend dict or collection.UserDict instead of ABCs. The main value of ABCs is documenting and formalizing the minimal interfaces for mapping. . from collections.abc import Mapping my_dict = {} isinstance(my_dict, Mapping) . True . The dict has one requirement and that is that the keys should be hashable. What do you mean by hashable? . An object is hashable if it has a hash value which never changes during its lifetime (it needs a __hash__() method), and can be compared to other objects (it needs an __eq__() method). Hashable objects which compare equal must have the same hash value. . print(hash((1, 2, 3)), hash(&#39;1, 2, 3&#39;), hash(1)) print(hash([1, 2, 3])) . 529344067295497451 4576582733818374657 1 . TypeErrorTraceback (most recent call last) &lt;ipython-input-8-146e8d157a5b&gt; in &lt;module&gt; 1 print(hash((1, 2, 3)), hash(&#39;1, 2, 3&#39;), hash(1)) -&gt; 2 print(hash([1, 2, 3])) TypeError: unhashable type: &#39;list&#39; . a = dict(one=1, two=2, three=3) b = {&#39;one&#39;: 1, &#39;two&#39;: 2, &#39;three&#39;: 3} c = dict(zip([&#39;one&#39;, &#39;two&#39;, &#39;three&#39;], [1, 2, 3])) d = dict([(&#39;two&#39;, 2), (&#39;one&#39;, 1), (&#39;three&#39;, 3)]) e = dict({&#39;three&#39;: 3, &#39;two&#39;: 2, &#39;one&#39;:1}) a == b == c == d == e . True . dict Comprehensions . the syntax of listcomps and genexps can be used . nums = {num: str(num) for num in range(10)} nums . {0: &#39;0&#39;, 1: &#39;1&#39;, 2: &#39;2&#39;, 3: &#39;3&#39;, 4: &#39;4&#39;, 5: &#39;5&#39;, 6: &#39;6&#39;, 7: &#39;7&#39;, 8: &#39;8&#39;, 9: &#39;9&#39;} . Overview of Common Mapping Methods . There are 3 main dictionary types. dict, defaultdict, orderedDict. . Handlying Missing Keys with setdefault . dicts have a get function which is what is used most of the time when you want to handle missing keys (every pythonista knows this one!). In some cases where we have to handle key error and use a default value when the keys is not present don&#39;t use get to define the default value, instead use setdefault function. Use the 2 wisely. Most of the time setdefault() is a wise choice because using get() can lead to more searches. This is when you are inserting. if you also what to do a lookup... . Mappings with Flexible Key Lookup . There are 2 other methods to do this. . Use defaultdict - this expect a callable to be passed to the defaultdict constructor that will be called when there is a key error in the __getitem__. Note this will only be called for __getitem__ and not for other functions like .get(). Under the hood, it is using the __missing__ special methods. | subclass dict and add a __missing__ method - when __getitem__ is called with a key that is not present, it calls the __missing__ function if it is implemented to handle it. | from collections import defaultdict # takes a callable which is called when there is a key error d = defaultdict(list) d[0] # what happend? -&gt; calls list() to create list and inserts that into key . [] . but under the hood defaultdict uses the __missing__ method. This method is used to handle the missing values in any mapping object. . class PinToFun(dict): # the __getitem in dict calls this function def __missing__(self, key): if isinstance(key, str): # check to avoid recursion raise KeyError(key) return self[str(key)] def get(self, key, default=None): try: return self[key] except KeyError: return default def __contains__(self, key): return key in self.keys() or str(key) in self.keys() . pins = {&#39;0&#39;: &#39;I/O&#39;, &#39;1&#39;: &#39;LED&#39;} pins[&#39;0&#39;] . &#39;I/O&#39; . pins[0] . KeyErrorTraceback (most recent call last) &lt;ipython-input-12-bc9cb425f661&gt; in &lt;module&gt; -&gt; 1 pins[0] KeyError: 0 . pins_improved = PinToFun({&#39;0&#39;: &#39;I/O&#39;}) pins_improved[0] . &#39;I/O&#39; . pins_improved.get(0) . &#39;I/O&#39; . Variations of Dict: . collections.OrderedDict: Maintains keys in insertion order. Hence iteration is predictable. . collections.ChainMap: class is provided for quickly linking a number of mappings so they can be treated as a single unit. It is often much faster than creating a new dictionary and running multiple update()calls . collections.Counter: Holds the integer count of each key. Can be used to count instances of hashable objects. has addition functions like most_common to return the odered list of tuples. . from collections import Counter ct = Counter(&#39;abaaachdddrllkk&#39;) ct . Counter({&#39;a&#39;: 4, &#39;b&#39;: 1, &#39;c&#39;: 1, &#39;h&#39;: 1, &#39;d&#39;: 3, &#39;r&#39;: 1, &#39;l&#39;: 2, &#39;k&#39;: 2}) . collections.UserDict: Used as base class for creating new mapping classes. The main reason we don&#39;t use dict as base class is that it has some implementation shortcuts that we will have to override in order to make it work. Note that UserDict does not inherit from dict instead has data, which is a dict instance to avoid possible recursion issues. . we will now modify the PinToFun class using this to show its effectiveness. . import collections class PinToFun(collections.UserDict): def __missing__(self, key): if isinstance(key, str): raise KeyError(key) return self[str(key)] def __contains__(self, key): return str(key) in self.data def __setitem__(self, key, item): #here the data is accessed as an attribute self.data[str(key)] = item . pins = PinToFun({&#39;0&#39;: &#39;I/O&#39;, &#39;1&#39;: &#39;LED&#39;}) pins . {&#39;0&#39;: &#39;I/O&#39;, &#39;1&#39;: &#39;LED&#39;} . 0 in pins . True . Immutable Mappings . mapping types are mutable but if you want to constrain the user from making changes, use this. . Introducing MappingProxyType from types module. This returns a read-only by dynamic view of the original mapping. Hence updates can be seen but no changes can be performed using the mappingproxy . from types import MappingProxyType d = {1: &#39;A&#39;} d_proxy = MappingProxyType(d) d_proxy . mappingproxy({1: &#39;A&#39;}) . d_proxy[1] . &#39;A&#39; . d_proxy[0] = &#39;B&#39; . TypeErrorTraceback (most recent call last) &lt;ipython-input-3-c636e28161a2&gt; in &lt;module&gt; -&gt; 1 d_proxy[0] = &#39;B&#39; TypeError: &#39;mappingproxy&#39; object does not support item assignment . d[0] = &#39;B&#39; d_proxy[0] . &#39;B&#39; . Set Theory . An underused concept in python. The basic use is removing duplicate elements. Set elements must be hashable. . In addition to that sets also support basic set operations. . a | b - Union | a &amp; b - Intersection | a - b - Difference | . Sets have extremely fast membership functions. If used effectively it can make you code faster and easier to read. . l = [&#39;spam&#39;, &#39;eggs&#39;, &#39;spam&#39;, &#39;spam&#39;, &#39;spam&#39;] l . [&#39;spam&#39;, &#39;eggs&#39;, &#39;spam&#39;, &#39;spam&#39;, &#39;spam&#39;] . set(l) . {&#39;eggs&#39;, &#39;spam&#39;} . s = {1} type(s) . set . s . {1} . s.pop() . 1 . s # set() is used to denote empty set there is no literal notation for sets . set() . %time # this is faster and cleaner s = {1, 2, 3, 1} s . CPU times: user 1e+03 ns, sys: 0 ns, total: 1e+03 ns Wall time: 2.62 µs . {1, 2, 3} . %time s = set([1, 2, 3, 1]) s . CPU times: user 1 µs, sys: 4 µs, total: 5 µs Wall time: 8.58 µs . {1, 2, 3} . Using the literal set syntax is faster and more readable than calling the constructor set([1, 2, 3]). The latter is slower because when you use the literal, python directly calls the BUILD_SET bytecode to create the set. . from dis import dis #disassembe bytecode dis(&#39;{1}&#39;) . 1 0 LOAD_CONST 0 (1) 2 BUILD_SET 1 4 RETURN_VALUE . dis(&#39;set([1])&#39;) . 1 0 LOAD_NAME 0 (set) 2 LOAD_CONST 0 (1) 4 BUILD_LIST 1 6 CALL_FUNCTION 1 8 RETURN_VALUE . frozenset(range(10)) . frozenset({0, 1, 2, 3, 4, 5, 6, 7, 8, 9}) . The advantage of frozenset is that they are hashable while sets are not. So a frozenset can be used inside a set but nested sets are not possible. . f = frozenset(range(10)) s = set(range(10)) f, s . (frozenset({0, 1, 2, 3, 4, 5, 6, 7, 8, 9}), {0, 1, 2, 3, 4, 5, 6, 7, 8, 9}) . new_set = {f} new_set = {s} . TypeErrorTraceback (most recent call last) &lt;ipython-input-33-0e201e86858f&gt; in &lt;module&gt; 1 new_set = {f} -&gt; 2 new_set = {s} TypeError: unhashable type: &#39;set&#39; . {i for i in &#39;abcdeeefghhijkkkll&#39;} . {&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;, &#39;f&#39;, &#39;g&#39;, &#39;h&#39;, &#39;i&#39;, &#39;j&#39;, &#39;k&#39;, &#39;l&#39;} . dict and set under the Hood . dict and set has really fast membership operations (lookup) due to the fact that they are implemented using hash tables. Comparing this with something like a list, there is a world of difference. All this is due to the hash tables. . Hash Tables . It is implemented as a sparse array. Each cell in the array is called a bucket. In a dict table each bucket has 2 fields, a ref to the key and a ref to the value item. . Python tries to keep 1/3 of the buckets empty. If its size increases it is copied out to a know location with larger memory. The first set in putting an element inside is to hash the item. . To put an item in hash table, the first step is to calculate the hash value of the item key. This is a unique value for the given data type. The hash() function is called, which in turn uses the __hash__ for calculating the hash. . hash(1) . 1 . If 2 objs compare equal there hash values must be equal. . hash(1), hash(1.0) . (1, 1) . Also hashes for objects that are similar to should be as different as possible. . hash(1.001), hash(1.002) . (2305843009213441, 4611686018427393) . Note: There is a detailed overview of the hash table algorithms in the book. Please google for it to find it. (It is in page 89 in the book). I actually forgot all about hashes, shouldn&#39;t have skipped those classes in college... . Practical Consequeces of How dict Works . keys must be hashable objects - the object must support hash() funtion and eq() function. also if a == b the hash(a) == hash(b). By default all user objects are hashable. . | dicts have significant memory overhead - since dicts use sparese arrays they are not efficient. Note that if your using dicts in JSON style with one dict per object, a namedtuple is far more efficent alternative. . | Key search is fast (very fast) - hash tables are the reason. . | Key ordering depends on insertion order - Consider the case where a key collition happens. . | Adding items to dict may change the order of existing keys - this is why modifing the contents of a dict while iterating through it is a bad idea. If you need to scan and add items to a dict, do it in 2 steps. . | Practical Concequeces of how sets Work . similar to dict, sets and frozensets also implement hash tables but each bucket only holds a reference. Just like dicts but without a value to go with it. similar concequences as above. . to sum up . Dictionaries are a keystone of Python. Beyond the basic dict , the standard library offers handy, ready-to-use specialized mappings like defaultdict , OrderedDict , ChainMap , and Counter , all defined in the collections module. The same module also provides the easy-to-extend UserDict class. . Two powerful methods available in most mappings are setdefault and update . The setdefault method is used to update items holding mutable values, for example, in a dict of list values, to avoid redundant searches for the same key. The update method allows bulk insertion or overwriting of items from any other mapping, from iterables providing (key, value) pairs and from keyword arguments. Mapping constructors also use update internally, allowing instances to be initialized from mappings, iterables, or keyword arguments. . A clever hook in the mapping API is the missing method, which lets you customize what happens when a key is not found. The collections.abc module provides the Mapping and MutableMapping abstract base classes for reference and type checking. The little-known MappingProxyType from the types module creates immutable mappings. There are also ABCs for Set and Mutable Set . . The hash table implementation underlying dict and set is extremely fast. Understand‐ ing its logic explains why items are apparently unordered and may even be reordered behind our backs. There is a price to pay for all this speed, and the price is in memory. .",
            "url": "https://fluentpython.jjmachan.in/2021/07/25/ch3-dictionaries-and-sets.html",
            "relUrl": "/2021/07/25/ch3-dictionaries-and-sets.html",
            "date": " • Jul 25, 2021"
        }
        
    
  
    
        ,"post5": {
            "title": "Chapter 2: An Array of Sequences",
            "content": "Overview of build-in Sequence . Container Sequence They hold references of other objects. They can store different types of objects. Eg list, tuple, collections.deque. . | Flat Sequence Physically store the objects in its own memory space. Store similar values. Eg str, byte, memoryview, array.array . | they can also be catogrised as immutable and mutable. . List Comprehensions and Generator Expressions . Listcomps are more readable since they are only used to build new lists. They are also really powerfull. They are also specific, listcomps can only do one thing, build new lists. . [i for i in range(10)] . [0, 1, 2, 3, 4, 5, 6, 7, 8, 9] . Listcomps can also do everything the map and filter functions perform, without using python lambda. Its seems to be faster in simple use cases too. . colors = [&#39;black&#39;, &#39;white&#39;] sizes = [&#39;S&#39;, &#39;M&#39;, &#39;L&#39;, &#39;XL&#39;] # do not the order of the for loops determins the order of the product tshirts = [(color, size) for color in colors for size in sizes] tshirts . [(&#39;black&#39;, &#39;S&#39;), (&#39;black&#39;, &#39;M&#39;), (&#39;black&#39;, &#39;L&#39;), (&#39;black&#39;, &#39;XL&#39;), (&#39;white&#39;, &#39;S&#39;), (&#39;white&#39;, &#39;M&#39;), (&#39;white&#39;, &#39;L&#39;), (&#39;white&#39;, &#39;XL&#39;)] . Generator Expressions . Listcomps build lists, but to fill up all other sequences, genexp is the way to go. You can build tuples, arrays and other sequences from listcomps but genexps saves memory because they only generate one element at a time instead of storing the whole thing in memory with a list and just passing it into another constructor . symbols = &#39;$¢£¥€¤&#39; tuple(ord(symbol) for symbol in symbols) . (36, 162, 163, 165, 8364, 164) . genexp = (i for i in range(10)) listcomp = [i for i in range(10)] genexp, listcomp . (&lt;generator object &lt;genexpr&gt; at 0x7f382dfc30b0&gt;, [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]) . %%timeit # seems like genexps are faster too! for i in listcomp: #print(i) pass . 224 ns ± 1.3 ns per loop (mean ± std. dev. of 7 runs, 1000000 loops each) . %%timeit for i in genexp: #print(i) pass . 41.5 ns ± 0.399 ns per loop (mean ± std. dev. of 7 runs, 10000000 loops each) . import array array.array(&#39;I&#39;, (ord(symbol) for symbol in symbols)) . array(&#39;I&#39;, [36L, 194L, 162L, 194L, 163L, 194L, 165L, 226L, 130L, 172L, 194L, 164L]) . The main advantage of genexp is that they are never build in memory. So in cases where you just want to use the resulting sequence and not save it this becomes handy. This make genexps really scalable. For example if you took the cartician product we did with listcomps earlier and wanted to do that for a million colors and sizes just so that you can print them out will lead to huge use of memory, but if you use a genexp, only one item needs to be created when executing each loop. . Tuples are not just Immutable Lists . Tuples are immutable lists and records with no field names . Tuples as Records . tuples hold record, each item in the tuple holds data for one field and the position of the item gives its meaning. They work as good record because we can easily upack them in order. using * to grab excess items . traveler_ids = [(&#39;USA&#39;, &#39;31195855&#39;), (&#39;BRA&#39;, &#39;CE342567&#39;), (&#39;ESP&#39;, &#39;XDA205856&#39;)] for country, passport in sorted(traveler_ids): print(&#39;%s/%s&#39; % (country, passport)) . BRA/CE342567 ESP/XDA205856 USA/31195855 . one, two, *rest = range(1, 10) print(one, two) print(rest) . 1 2 [3, 4, 5, 6, 7, 8, 9] . Tuple unpacking does work with any interable object, you only have to ensure that when unpacking you map each individual item to 1 corresponding variable (except when the variable has a * operator like in the above example . nested tuples are also handled just like you would expect . metro_areas = [ (&#39;Tokyo&#39;, &#39;JP&#39;, 36.933, (35.689722, 139.691667)), # (&#39;Delhi NCR&#39;, &#39;IN&#39;, 21.935, (28.613889, 77.208889)), (&#39;Mexico City&#39;, &#39;MX&#39;, 20.142, (19.433333, -99.133333)), (&#39;New York-Newark&#39;, &#39;US&#39;, 20.104, (40.808611, -74.020386)), (&#39;Sao Paulo&#39;, &#39;BR&#39;, 19.649, (-23.547778, -46.635833)), ] print(&#39;{:15} | {:^9} | {:^9}&#39;.format(&#39;&#39;, &#39;lat.&#39; , &#39;long.&#39;)) fmt = &#39;{:15} | {:9.4f} | {:9.4f}&#39; for name, cc, population, (lat, long) in metro_areas: if long &lt;= 0: print(fmt.format(name, lat, long)) . | lat. | long. Mexico City | 19.4333 | -99.1333 New York-Newark | 40.8086 | -74.0204 Sao Paulo | -23.5478 | -46.6358 . Named Tuples . Names tuples function is a factory that produces a subclass of tuples that attaches field names and class names to it. They also use the same amt of memory as a tuple but less that an object would because it doesn&#39;t have a __dict__. This makes it ideal for used where you want an object to contain all the data that is associated with it but doesn&#39;t have function of its own . namedtuple( &lt;class name&gt; , &lt; field names: Optional(iter, str)&gt; ) . from collections import namedtuple City = namedtuple(&#39;City&#39;, &#39;city state country&#39;) Kochi = City(&#39;Kochi&#39;, &#39;Kerala&#39;, &#39;India&#39;) Kochi . City(city=&#39;Kochi&#39;, state=&#39;Kerala&#39;, country=&#39;India&#39;) . from collections import namedtuple # takes the name of the class and either a iterable with field names or as a string in which field # names are seperated by space City = namedtuple(&#39;City&#39;, &#39;name county population coordinates&#39;) tokyo = City(&#39;Tokyo&#39;, &#39;JP&#39;, 36.933, (35.689722, 139.691667)) tokyo . City(name=&#39;Tokyo&#39;, county=&#39;JP&#39;, population=36.933, coordinates=(35.689722, 139.691667)) . tokyo.population . 36.933 . NamedTuple has a few attributes in addition to the ones in tuple. the most useful ones are _fields, _make(iterable), _asdict() . print(City._fields) # gets the field names print(tokyo._asdict()) LatLong = namedtuple(&#39;LatLong&#39;, &#39;lat long&#39;) delhi_data = (&#39;Delhi NCR&#39;, &#39;IN&#39;, 21.935, LatLong(28.613889, 77.208889)) print(City._make(delhi_data)) # allows you to init a named tuple from a # iterable; City(*delhi_data) would do the same . (&#39;name&#39;, &#39;county&#39;, &#39;population&#39;, &#39;coordinates&#39;) {&#39;name&#39;: &#39;Tokyo&#39;, &#39;county&#39;: &#39;JP&#39;, &#39;population&#39;: 36.933, &#39;coordinates&#39;: (35.689722, 139.691667)} City(name=&#39;Delhi NCR&#39;, county=&#39;IN&#39;, population=21.935, coordinates=LatLong(lat=28.613889, long=77.208889)) . Slicing . This is pretty straight forward but none the less very powerful. Lets see all their advanced usecases here. . Why Slices and Range exclude the last item? . This is because that way its more intutive for zero-based indexing used in python and c. . Slice Objects . How slice is works . strs = &#39;bicycle&#39; strs[::-1], strs[::3], strs[::-2] . (&#39;elcycib&#39;, &#39;bye&#39;, &#39;eccb&#39;) . Internally [a:b:c] creates a slice object slice(a, b, c) which is invoked by the obj.__getitem__(slice(start, stop, step)). This is handy since you can now get slice working your own objects. . You can also assign to slices. . reverse = slice(None, None, -1) strs[reverse] . &#39;elcycib&#39; . Multidimensional Slicing and Ellipsis . the [] operator can also take multiple indexes or slices seperated by commas. This is used, for instance, in the external NumPy package, where items of a two-dimensional numpy.ndarray can be fetched using the syntax a[i, j] or 2-d slice as a[m:n, k:l] . The ellipsis (3 full stops ...) is valid token by the python parser. In Numpy it is used as a shortcut when slicing arrays of many dimensions for example if x is a 4-d array x[i, ...] is a shortcut for x[i, :, :, :,] . Assigning to Slices . Mutable sequnces can be grafted or modified in place using the slice notation. You can also del slices. . l = list(range(10)) l . [0, 1, 2, 3, 4, 5, 6, 7, 8, 9] . l[2:5] = [20, 30] l . [0, 1, 20, 30, 5, 6, 7, 8, 9] . del l[5:7] l . [0, 1, 20, 30, 5, 8, 9] . l[2:5] = 100 . TypeErrorTraceback (most recent call last) &lt;ipython-input-10-da8b10461280&gt; in &lt;module&gt; -&gt; 1 l[2:5] = 100 TypeError: can only assign an iterable . l[2:5] = [100] l . [0, 1, 100, 8, 9] . Using + and * with Seqences . concatenation is a common operation with any sequence but there are some subtle details as to how they work. When using the */+ both sequences have to be of the same time and none of them is modified, instead a new on is created . &#39;abc&#39; * 3 . &#39;abcabcabc&#39; . &#39;abc&#39; + &#39;def&#39; . &#39;abcdef&#39; . Building Lists of Lists . now this can bite you when you don&#39;t expect it to. Sometimes you want to init a new list with certain number of nested lists, the best way to do this is with list comprehension. . board = [[&#39;_&#39;] * 3 for i in range(3)] board . [[&#39;_&#39;, &#39;_&#39;, &#39;_&#39;], [&#39;_&#39;, &#39;_&#39;, &#39;_&#39;], [&#39;_&#39;, &#39;_&#39;, &#39;_&#39;]] . board[2][2] = &#39;X&#39; board . [[&#39;_&#39;, &#39;_&#39;, &#39;_&#39;], [&#39;_&#39;, &#39;_&#39;, &#39;_&#39;], [&#39;_&#39;, &#39;_&#39;, &#39;X&#39;]] . weird_board = [[&#39;_&#39;]*3 ]*3 weird_board[2][2] = &#39;2&#39; weird_board . [[&#39;_&#39;, &#39;_&#39;, &#39;2&#39;], [&#39;_&#39;, &#39;_&#39;, &#39;2&#39;], [&#39;_&#39;, &#39;_&#39;, &#39;2&#39;]] . Here the outer list is made up of refferences of the inner list. Here the issue is that the above code acts similar to this . row = [&#39;_&#39;] * 3 board = [] for i in range(3): board.append(row) . The same row gets appended 3 times. On the other hand using list comprehension is similar to this code . board = [] for i in range(3): row = [&#39;_&#39;] * 3 board.append(row) . Augmented Assignment with Sequences . Using operators like *= += behaves very differently depending on the first operand. The special method that works is __iadd__(inplace addition). If it is not implemented, pythons falls back to __add__. If __iadd__ is present and the sequence is mutable then the operation happens in place. If either of the conditions is false then pythons calls __add__ and assigns the result to the object. . l = [1, 2, 3] print(l, id(l)) l *= 2 print(l, id(l)) t = (1, 2, 3) print(t, id(t)) t *= 2 print(t, id(t)) . [1, 2, 3] 140649174697408 [1, 2, 3, 1, 2, 3] 140649174697408 (1, 2, 3) 140649174633216 (1, 2, 3, 1, 2, 3) 140649217792800 . Sort and Sorted . list.sort() sorts the list in place and returns a None object to signal this. Infact this is a common practice in Python standard lib to return None from functions that operate on objects in place. . The build-in function sorted() on the other hand creates a new array and returns it. . Both of them take 2 arguments . reverse - which is a flag which tells to sort in reverse order | key - A one argument function that generates a key for each element to sort | fruits = [&#39;grape&#39;, &#39;raspberry&#39;, &#39;apple&#39;, &#39;banana&#39;] sorted(fruits) . [&#39;apple&#39;, &#39;banana&#39;, &#39;grape&#39;, &#39;raspberry&#39;] . fruits . [&#39;grape&#39;, &#39;raspberry&#39;, &#39;apple&#39;, &#39;banana&#39;] . fruits.sort() . fruits . [&#39;apple&#39;, &#39;banana&#39;, &#39;grape&#39;, &#39;raspberry&#39;] . Managing Ordered Sequences with bisect . bisect finds the insert point for an item in a list and returns the index, then we use list.insert(index, item) to add the item to the corresponding index. the bisect module also has an efficient implementation of binary search which can be used. . bisect offers 2 functions - bisect and insort . import bisect import sys HAYSTACK = [1, 4, 5, 6, 8, 12, 15, 20, 21, 23, 23, 26, 29, 30] NEEDLES = [0, 1, 2, 5, 8, 10, 22, 23, 29, 30, 31] ROW_FMT = &#39;{0:2d} @ {1:2d} {2}{0:&lt;2d}&#39; def demo(bisect_fn): for needle in reversed(NEEDLES): position = bisect_fn(HAYSTACK, needle) offset = position * &#39; |&#39; print(ROW_FMT.format(needle, position, offset)) def main(add_to=&#39;right&#39;): if add_to == &#39;left&#39;: bisect_fn = bisect.bisect_left else: bisect_fn = bisect.bisect print(&#39;DEMO: &#39;, bisect_fn.__name__) print(&#39;haystack -&gt;&#39;, &#39; &#39;.join(&#39;%2d&#39;%n for n in HAYSTACK)) demo(bisect_fn) . main() . DEMO: bisect_right haystack -&gt; 1 4 5 6 8 12 15 20 21 23 23 26 29 30 31 @ 14 | | | | | | | | | | | | | |31 30 @ 14 | | | | | | | | | | | | | |30 29 @ 13 | | | | | | | | | | | | |29 23 @ 11 | | | | | | | | | | |23 22 @ 9 | | | | | | | | |22 10 @ 5 | | | | |10 8 @ 5 | | | | |8 5 @ 3 | | |5 2 @ 1 |2 1 @ 1 |1 0 @ 0 0 . main(add_to=&#39;left&#39;) . DEMO: bisect_left haystack -&gt; 1 4 5 6 8 12 15 20 21 23 23 26 29 30 31 @ 14 | | | | | | | | | | | | | |31 30 @ 13 | | | | | | | | | | | | |30 29 @ 12 | | | | | | | | | | | |29 23 @ 9 | | | | | | | | |23 22 @ 9 | | | | | | | | |22 10 @ 5 | | | | |10 8 @ 4 | | | |8 5 @ 2 | |5 2 @ 1 |2 1 @ 0 1 0 @ 0 0 . bisect has is really bisect_right, which inserts the same element always to the right of the corresponing element in the list. It also has a sister function bisect_left which corresponds to inserting the same item to left of the matching item in the list . bisect has another function called bisect.insort(seq, item) which inserts an the item into seq, this is much faster than using insert() . %%time haystack = HAYSTACK[:] idx = bisect.bisect(haystack, 19) haystack.insert(idx, 19) print(haystack) . [1, 4, 5, 6, 8, 12, 15, 19, 20, 21, 23, 23, 26, 29, 30] CPU times: user 2.41 ms, sys: 0 ns, total: 2.41 ms Wall time: 1.51 ms . %%time haystack = HAYSTACK[:] bisect.insort(haystack, 19) print(haystack) . [1, 4, 5, 6, 8, 12, 15, 19, 20, 21, 23, 23, 26, 29, 30] CPU times: user 161 µs, sys: 30 µs, total: 191 µs Wall time: 198 µs . import bisect import random SIZE = 7 my_list = [] for i in range(SIZE): new_item = random.randrange(SIZE*2) bisect.insort(my_list, new_item) print(&#39;%2d -&gt;&#39;%new_item, my_list) . 5 -&gt; [5] 8 -&gt; [5, 8] 3 -&gt; [3, 5, 8] 6 -&gt; [3, 5, 6, 8] 13 -&gt; [3, 5, 6, 8, 13] 0 -&gt; [0, 3, 5, 6, 8, 13] 9 -&gt; [0, 3, 5, 6, 8, 9, 13] . When a List is Not all the Answer . when we are starting out we tend to overuse lists for everything. But there are times when other sequence objects make more sense. Let explore some of them. . if you need large list of floating points it&#39;s better to user arrays since the only store the numerical value and not float object, just like how C/C++ implements. . | if you need FIFO, LIFO operation consider the deque . | if you do frequent membership checks, a set is much more efficient (note they are not a sequence since they are not ordered). . | . Arrays . Array can be used to store same type of numeraical data and are as efficient as C-arrays. You can also provide a typecode (a letter) to determine the underlying C type used. . from array import array from random import random # create a array to hold decimal float floats = array(&#39;d&#39;, (random() for i in range(10**7))) . floats[-1] . 0.19034769013593422 . fp = open(&#39;floats.bin&#39;, &#39;wb&#39;) floats.tofile(fp) # size = 77M fp.close() . float2 = array(&#39;d&#39;) fp = open(&#39;floats.bin&#39;, &#39;rb&#39;) float2.fromfile(fp, 10**7) fp.close() float2[-1] . 0.19034769013593422 . float2 == floats . True . Here we are creating a new int array using the old HAYSTACK . HAYSTACK . [1, 4, 5, 6, 8, 12, 15, 20, 21, 23, 23, 26, 29, 30] . a = array(&#39;i&#39;, reversed(HAYSTACK)) a . array(&#39;i&#39;, [30, 29, 26, 23, 23, 21, 20, 15, 12, 8, 6, 5, 4, 1]) . Array doesn&#39;t have a built-in sort mechanism, you can create a new sorted array easily though. . a = array(a.typecode, sorted(a)) a . array(&#39;i&#39;, [1, 4, 5, 6, 8, 12, 15, 20, 21, 23, 23, 26, 29, 30]) . bisect.bisect(a, 8), bisect.insort(a, 8), a . (5, None, array(&#39;i&#39;, [1, 4, 5, 6, 8, 8, 12, 15, 20, 21, 23, 23, 26, 29, 30])) . Memory Views . A memoryview is essentially a generalized NumPy array structure in Python itself (without the math). It allows you to share memory between data-structures (things like PIL images, SQLlite databases, NumPy arrays, etc.) without first copying. This is very important for large data sets Travis Oliphant, lead author of Num-py memoryview has a case method that returns yet another memoryview object which is sharing the same memory. . import array . numbers = array.array(&#39;h&#39;, [-2, -1, 0, 1, 2]) memv = memoryview(numbers) len(memv) # apparently there is some issue with python3 hence not used # ref - https://stackoverflow.com/questions/4877866/why-is-it-not-possible-to-get-a-py-buffer-from-an-array-object . 5 . print(memv[0]) memv_oct = memv.cast(&#39;B&#39;) memv_oct.tolist(), memv_oct[5], numbers . -2 . ([254, 255, 255, 255, 0, 0, 1, 0, 2, 0], 0, array(&#39;h&#39;, [-2, -1, 0, 1, 2])) . Numpy ans SciPy . Now if your doing advanced array and matrix operation numpy and scipy are your gotos. These libs are the reason by python is so popular in the scientific communities. The key point of these libraries was that they were fast and reliable because it leverages the widely used C and Fortran code base. . Deque and other Queues . lists are great but constrained for appending or poping from the left, deque on the other hand is optimized for operating from both sides (but is poor for operations in the middle). We use the Queue data structure for a wide range of algos and hence we have an optimised implementation of that in python. . collections.deque is a thread-safe double-ended queue designed for fast insertion and deletion from both ends. They can also be bounded to a fixed length so if you add any new elements after that, the data will be discarded from the top (first entered data point first). . from collections import deque dq = deque(range(10), maxlen=10) dq . deque([0, 1, 2, 3, 4, 5, 6, 7, 8, 9]) . dq.rotate(3) dq . deque([7, 8, 9, 0, 1, 2, 3, 4, 5, 6]) . dq.append(2) dq . deque([8, 9, 0, 1, 2, 3, 4, 5, 6, 2]) . dq.appendleft(-1) dq . deque([-1, 8, 9, 0, 1, 2, 3, 4, 5, 6]) . dq.extend([11, 12, 13]) dq . deque([0, 1, 2, 3, 4, 5, 6, 11, 12, 13]) . dq.maxlen . 10 . dq.extendleft([10, 20, 30, 40]) dq . deque([40, 30, 20, 10, 0, 1, 2, 3, 4, 5]) . the append() and popleft operations are atomic, so deque is safe to use as a LIFO queue in multithreaded applications without the need for locks. . Other implementations of Queues . queue: This provides the synchronized (i.e., thread-safe) classes Queue , LifoQueue , and PriorityQueue . These are used for safe communication between threads. All three classes can be bounded by providing a maxsize argument greater than 0 to the constructor. However, they don’t discard items to make room as deque does. In‐stead, when the queue is full the insertion of a new item blocks—i.e., it waits until some other thread makes room by taking an item from the queue, which is useful to throttle the number of live threads. . multiprocessing Implements its own bounded Queue , very similar to queue.Queue but designed for interprocess communication. A specialized multiprocessing.JoinableQueue is also available for easier task management. . asyncio Newly added to Python 3.4, asyncio provides Queue , LifoQueue , PriorityQueue, and JoinableQueue with APIs inspired by the classes contained in the queue and multiprocessing modules, but adapted for managing tasks in asynchronous pro‐gramming. . heapq In contrast to the previous three modules, heapq does not implement a queue class, but provides functions like heappush and heappop that let you use a mutable sequence as a heap queue or priority queue. .",
            "url": "https://fluentpython.jjmachan.in/2021/07/19/ch2-array-of-sequences.html",
            "relUrl": "/2021/07/19/ch2-array-of-sequences.html",
            "date": " • Jul 19, 2021"
        }
        
    
  
    
        ,"post6": {
            "title": "Chapter 1: Data Model",
            "content": "Pythonic Card Deck . To undertant how python works as a framework it is crutial that you get the Python Data Model. Python is very consistent and by that I mean that once you have some experince with the language you can start to correctly make informed guesses on other features about python even if its new. This will help you make your objects more pythonic by leveraging the options python has for: . Iteration | Collections | Attribute access | Operator overloading | Function and method invocation | Object creation and destruction | String representation and formatting | Managed contexts (i.e., with blocks) | Studing these will give you the power to make your own python object play nicely with the python language and use many of the freatures mentioned above. In short makes you code &quot;pythonic&quot;. . Let see an example to show you the power of __getitem__ and __len__. . import collections # namedtuple - tuples with names for each value in it (much like a class) Card = collections.namedtuple(&#39;Card&#39;, [&#39;rank&#39;, &#39;suit&#39;]) c = Card(&#39;7&#39;, &#39;diamonds&#39;) # individual card object print(c) print(c.rank, c.suit) . Card(rank=&#39;7&#39;, suit=&#39;diamonds&#39;) 7 diamonds . class FrenchDeck: ranks = [str(n) for n in range(2, 11)] + list(&#39;JQKA&#39;) suits = &#39;spades diamonds clubs hearts&#39;.split() def __init__(self): self._cards = [Card(rank, suit) for suit in self.suits for rank in self.ranks] def __len__(self): return len(self._cards) def __getitem__(self, position): return self._cards[position] . deck = FrenchDeck() # with this simple class, we can already use `len` and `__getitem__` len(deck), deck[0] . (52, Card(rank=&#39;2&#39;, suit=&#39;spades&#39;)) . Now we have created a class FrenchDeck that is short but still packs a punch. All the basic operations are supported. Now imagine we have another usecase to pick a random card. Normally we would add another function but in this case we can use pythons existing lib function random.choice(). . from random import choice choice(deck) . Card(rank=&#39;5&#39;, suit=&#39;hearts&#39;) . We’ve just seen two advantages of using special methods to leverage the Python data model:&gt; 1. The users of your classes don’t have to memorize arbitrary method names for stan‐dard operations (“How to get the number of items? Is it .size() , .length() , or what?”). . It’s easier to benefit from the rich Python standard library and avoid reinventing the wheel, like the random.choice function. | But we have even more features . deck[1:5] . [Card(rank=&#39;3&#39;, suit=&#39;spades&#39;), Card(rank=&#39;4&#39;, suit=&#39;spades&#39;), Card(rank=&#39;5&#39;, suit=&#39;spades&#39;), Card(rank=&#39;6&#39;, suit=&#39;spades&#39;)] . for card in deck: if card.rank == &#39;K&#39;: print(card) . Card(rank=&#39;K&#39;, suit=&#39;spades&#39;) Card(rank=&#39;K&#39;, suit=&#39;diamonds&#39;) Card(rank=&#39;K&#39;, suit=&#39;clubs&#39;) Card(rank=&#39;K&#39;, suit=&#39;hearts&#39;) . # the in operator does a sequential scan. Card(&#39;Q&#39;, &#39;spades&#39;) in deck . True . Card(&#39;M&#39;, &#39;spades&#39;) in deck . False . we can also make use the build-in sorted() function. We just need to proved a function for providing the values of the cards. Here the logic is provided in spedes_high . suit_value = dict(spades=3, hearts=2, diamonds=1, clubs=0) def spades_high(card): rank_value = FrenchDeck.ranks.index(card.rank) return rank_value*len(suit_value) + suit_value[card.suit] . for card in sorted(deck, key=spades_high)[:10]: print(card) . Card(rank=&#39;2&#39;, suit=&#39;clubs&#39;) Card(rank=&#39;2&#39;, suit=&#39;diamonds&#39;) Card(rank=&#39;2&#39;, suit=&#39;hearts&#39;) Card(rank=&#39;2&#39;, suit=&#39;spades&#39;) Card(rank=&#39;3&#39;, suit=&#39;clubs&#39;) Card(rank=&#39;3&#39;, suit=&#39;diamonds&#39;) Card(rank=&#39;3&#39;, suit=&#39;hearts&#39;) Card(rank=&#39;3&#39;, suit=&#39;spades&#39;) Card(rank=&#39;4&#39;, suit=&#39;clubs&#39;) Card(rank=&#39;4&#39;, suit=&#39;diamonds&#39;) . Although FrenchDeck implicitly inherits from object its functionality is not inherited, but comes from leveraging the data model and composition. By implementing the special methods __len__ and __getitem__ , our FrenchDeck behaves like a standard Python sequence, allowing it to benefit from core language features (e.g., iteration and slicing). and from the standard library, as shown by the examples using random.choice , reversed , and sorted . Thanks to composition, the __len__ and __getitem__ imple‐ mentations can hand off all the work to a list object, self._cards . . How special methods are used . Normally you just define these special methods and call them via the inbuild methods like len() in [index] instead of calling it via object.__len__(). This gives you speed up in some cases and also plays nicely with other other python library functions since they all are now interfacing with the same endpoints. . Enumerating Numeric Types . Special methods can also be used to repond to operators like +, - etc. We will see an example of vector operations. . from math import hypot . class Vector: def __init__(self, x=0, y=0): self.x = x self.y = y def __repr__(self): return &#39;Vector(%d, %d)&#39; %(self.x, self.y) def __abs__(self): return hypot(self.x, self.y) def __bool__(self): return bool(self.x or self.y) def __add__(self, other): x = self.x + other.x y = self.y + other.y return Vector(x, y) def __mul__(self, scalar): x = scalar * self.x y = scalar * self.y return Vector(x, y) . v = Vector(3, 4) a = Vector(0, 0) print(v) print(abs(v)) print(v*2) print(v + a) . Vector(3, 4) 5.0 Vector(6, 8) Vector(3, 4) . As you can see we implemented many special methods but we don&#39;t directly invoke them. The special methods are to be invoked by the interpretor most of the time, unless you are doing a lot of metaprogramming. . bool(a) . True . String Representation . We use the __repr__ special method to get the buildin string representation of of the object for inspection (note the usage in vector object. There are also other special methods like __repr__with__str__ which is called by str() or __str__ which is used to return a string for display to the end user. If your only implementing 1 function stick with __repr__ since print() will fall back to that if __str__ is not found. . Arithmetic Operators . In the above example we have implemented __add__ and __mul__. Note in both cases we are returning new object, reading from self, and other. This is the expected behaviour. . Boolean Value of Custom Type . In python any object can be used in a boolean context. If __bool__ or __len__ is not implemented then the object will be truthy by default. IF __bool__ is implemented that is called, if not python calls __len__ and checks if the length is 0. . class Test: def __init__(self, x): self.x = x t = Test(0) t, bool(t) . (&lt;__main__.Test at 0x7fed149a53a0&gt;, True) . class Test: def __init__(self, x): self.x = x def __bool__(self): return bool(self.x) t = Test(0) t, bool(t) . (&lt;__main__.Test at 0x7fed149acd30&gt;, False) . Why len is Not a Method . Practicality beats purity . len (similar to abs) in built-in data types, has a shortcut implmentation in CPython and they are just returning their length from the values defined in the c struct code. This makes it super fast for built-in data types. You can also consider these as unary operations. .",
            "url": "https://fluentpython.jjmachan.in/2021/07/02/ch1-data-model.html",
            "relUrl": "/2021/07/02/ch1-data-model.html",
            "date": " • Jul 2, 2021"
        }
        
    
  
    
        ,"post7": {
            "title": "Fastpages Notebook Blog Post",
            "content": "you can open it at http://localhost:4000/jupyter/2020/02/20/test.html . About . This notebook is a demonstration of some of capabilities of fastpages with notebooks. . With fastpages you can save your jupyter notebooks into the _notebooks folder at the root of your repository, and they will be automatically be converted to Jekyll compliant blog posts! . Front Matter . The first cell in your Jupyter Notebook or markdown blog post contains front matter. Front matter is metadata that can turn on/off options in your Notebook. It is formatted like this: . # &quot;My Title&quot; &gt; &quot;Awesome summary&quot; - toc:true- branch: master - badges: true - comments: true - author: Hamel Husain &amp; Jeremy Howard - categories: [fastpages, jupyter] . Setting toc: true will automatically generate a table of contents | Setting badges: true will automatically include GitHub and Google Colab links to your notebook. | Setting comments: true will enable commenting on your blog post, powered by utterances. | . The title and description need to be enclosed in double quotes only if they include special characters such as a colon. More details and options for front matter can be viewed on the front matter section of the README. . Markdown Shortcuts . A #hide comment at the top of any code cell will hide both the input and output of that cell in your blog post. . A #hide_input comment at the top of any code cell will only hide the input of that cell. . The comment #hide_input was used to hide the code that produced this. . put a #collapse-hide flag at the top of any cell if you want to hide that cell by default, but give the reader the option to show it: . import pandas as pd import altair as alt . . put a #collapse-show flag at the top of any cell if you want to show that cell by default, but give the reader the option to hide it: . cars = &#39;https://vega.github.io/vega-datasets/data/cars.json&#39; movies = &#39;https://vega.github.io/vega-datasets/data/movies.json&#39; sp500 = &#39;https://vega.github.io/vega-datasets/data/sp500.csv&#39; stocks = &#39;https://vega.github.io/vega-datasets/data/stocks.csv&#39; flights = &#39;https://vega.github.io/vega-datasets/data/flights-5k.json&#39; . . place a #collapse-output flag at the top of any cell if you want to put the output under a collapsable element that is closed by default, but give the reader the option to open it: . print(&#39;The comment #collapse-output was used to collapse the output of this cell by default but you can expand it.&#39;) . The comment #collapse-output was used to collapse the output of this cell by default but you can expand it. . . Interactive Charts With Altair . Charts made with Altair remain interactive. Example charts taken from this repo, specifically this notebook. . Example 1: DropDown . # use specific hard-wired values as the initial selected values selection = alt.selection_single( name=&#39;Select&#39;, fields=[&#39;Major_Genre&#39;, &#39;MPAA_Rating&#39;], init={&#39;Major_Genre&#39;: &#39;Drama&#39;, &#39;MPAA_Rating&#39;: &#39;R&#39;}, bind={&#39;Major_Genre&#39;: alt.binding_select(options=genres), &#39;MPAA_Rating&#39;: alt.binding_radio(options=mpaa)} ) # scatter plot, modify opacity based on selection alt.Chart(df).mark_circle().add_selection( selection ).encode( x=&#39;Rotten_Tomatoes_Rating:Q&#39;, y=&#39;IMDB_Rating:Q&#39;, tooltip=&#39;Title:N&#39;, opacity=alt.condition(selection, alt.value(0.75), alt.value(0.05)) ) . Example 2: Tooltips . alt.Chart(df).mark_circle().add_selection( alt.selection_interval(bind=&#39;scales&#39;, encodings=[&#39;x&#39;]) ).encode( alt.X(&#39;Rotten_Tomatoes_Rating&#39;, type=&#39;quantitative&#39;), alt.Y(&#39;IMDB_Rating&#39;, type=&#39;quantitative&#39;, axis=alt.Axis(minExtent=30)), # y=alt.Y(&#39;IMDB_Rating:Q&#39;, ), # use min extent to stabilize axis title placement tooltip=[&#39;Title:N&#39;, &#39;Release_Date:N&#39;, &#39;IMDB_Rating:Q&#39;, &#39;Rotten_Tomatoes_Rating:Q&#39;] ).properties( width=500, height=400 ) . Example 3: More Tooltips . label = alt.selection_single( encodings=[&#39;x&#39;], # limit selection to x-axis value on=&#39;mouseover&#39;, # select on mouseover events nearest=True, # select data point nearest the cursor empty=&#39;none&#39; # empty selection includes no data points ) # define our base line chart of stock prices base = alt.Chart().mark_line().encode( alt.X(&#39;date:T&#39;), alt.Y(&#39;price:Q&#39;, scale=alt.Scale(type=&#39;log&#39;)), alt.Color(&#39;symbol:N&#39;) ) alt.layer( base, # base line chart # add a rule mark to serve as a guide line alt.Chart().mark_rule(color=&#39;#aaa&#39;).encode( x=&#39;date:T&#39; ).transform_filter(label), # add circle marks for selected time points, hide unselected points base.mark_circle().encode( opacity=alt.condition(label, alt.value(1), alt.value(0)) ).add_selection(label), # add white stroked text to provide a legible background for labels base.mark_text(align=&#39;left&#39;, dx=5, dy=-5, stroke=&#39;white&#39;, strokeWidth=2).encode( text=&#39;price:Q&#39; ).transform_filter(label), # add text labels for stock prices base.mark_text(align=&#39;left&#39;, dx=5, dy=-5).encode( text=&#39;price:Q&#39; ).transform_filter(label), data=stocks ).properties( width=500, height=400 ) . Data Tables . You can display tables per the usual way in your blog: . df[[&#39;Title&#39;, &#39;Worldwide_Gross&#39;, &#39;Production_Budget&#39;, &#39;Distributor&#39;, &#39;MPAA_Rating&#39;, &#39;IMDB_Rating&#39;, &#39;Rotten_Tomatoes_Rating&#39;]].head() . Title Worldwide_Gross Production_Budget Distributor MPAA_Rating IMDB_Rating Rotten_Tomatoes_Rating . 0 The Land Girls | 146083.0 | 8000000.0 | Gramercy | R | 6.1 | NaN | . 1 First Love, Last Rites | 10876.0 | 300000.0 | Strand | R | 6.9 | NaN | . 2 I Married a Strange Person | 203134.0 | 250000.0 | Lionsgate | None | 6.8 | NaN | . 3 Let&#39;s Talk About Sex | 373615.0 | 300000.0 | Fine Line | None | NaN | 13.0 | . 4 Slam | 1087521.0 | 1000000.0 | Trimark | R | 3.4 | 62.0 | . Images . Local Images . You can reference local images and they will be copied and rendered on your blog automatically. You can include these with the following markdown syntax: . ![](my_icons/fastai_logo.png) . . Remote Images . Remote images can be included with the following markdown syntax: . ![](https://image.flaticon.com/icons/svg/36/36686.svg) . . Animated Gifs . Animated Gifs work, too! . ![](https://upload.wikimedia.org/wikipedia/commons/7/71/ChessPawnSpecialMoves.gif) . . Captions . You can include captions with markdown images like this: . ![](https://www.fast.ai/images/fastai_paper/show_batch.png &quot;Credit: https://www.fast.ai/2020/02/13/fastai-A-Layered-API-for-Deep-Learning/&quot;) . . Other Elements . GitHub Flavored Emojis . Typing I give this post two :+1:! will render this: . I give this post two :+1:! . Tweetcards . Typing &gt; twitter: https://twitter.com/jakevdp/status/1204765621767901185?s=20 will render this: Altair 4.0 is released! https://t.co/PCyrIOTcvvTry it with: pip install -U altairThe full list of changes is at https://t.co/roXmzcsT58 ...read on for some highlights. pic.twitter.com/vWJ0ZveKbZ . &mdash; Jake VanderPlas (@jakevdp) December 11, 2019 . Youtube Videos . Typing &gt; youtube: https://youtu.be/XfoYk_Z5AkI will render this: . Boxes / Callouts . Typing &gt; Warning: There will be no second warning! will render this: . Warning: There will be no second warning! . Typing &gt; Important: Pay attention! It&#39;s important. will render this: . Important: Pay attention! It&#8217;s important. . Typing &gt; Tip: This is my tip. will render this: . Tip: This is my tip. . Typing &gt; Note: Take note of this. will render this: . Note: Take note of this. . Typing &gt; Note: A doc link to [an example website: fast.ai](https://www.fast.ai/) should also work fine. will render in the docs: . Note: A doc link to an example website: fast.ai should also work fine. . Footnotes . You can have footnotes in notebooks, however the syntax is different compared to markdown documents. This guide provides more detail about this syntax, which looks like this: . For example, here is a footnote {% fn 1 %}. And another {% fn 2 %} {{ &#39;This is the footnote.&#39; | fndetail: 1 }} {{ &#39;This is the other footnote. You can even have a [link](www.github.com)!&#39; | fndetail: 2 }} . For example, here is a footnote 1. . And another 2 . 1. This is the footnote.↩ . 2. This is the other footnote. You can even have a link!↩ .",
            "url": "https://fluentpython.jjmachan.in/jupyter/2020/02/20/test.html",
            "relUrl": "/jupyter/2020/02/20/test.html",
            "date": " • Feb 20, 2020"
        }
        
    
  

  
  

  

  
  

  
  

  
  

  
  

  
  

  
      ,"page7": {
          "title": "",
          "content": "Sitemap: {{ “sitemap.xml” | absolute_url }} | .",
          "url": "https://fluentpython.jjmachan.in/robots.txt",
          "relUrl": "/robots.txt",
          "date": ""
      }
      
  

}